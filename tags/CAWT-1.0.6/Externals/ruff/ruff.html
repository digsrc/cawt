<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"><html><head><title>Ruff! - Runtime Formatting Function Reference (V0.4)</title>
<style>

/*
Copyright (c) 2009, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.net/yui/license.txt
version: 2.7.0
*/
html{color:#000;background:#FFF;}body,div,dl,dt,dd,ul,ol,li,h1,h2,h3,h4,h5,h6,pre,code,form,fieldset,legend,input,button,textarea,p,blockquote,th,td{margin:0;padding:0;}table{border-collapse:collapse;border-spacing:0;}fieldset,img{border:0;}address,caption,cite,code,dfn,em,strong,th,var,optgroup{font-style:inherit;font-weight:inherit;}del,ins{text-decoration:none;}li{list-style:none;}caption,th{text-align:left;}h1,h2,h3,h4,h5,h6{font-size:100%;font-weight:normal;}q:before,q:after{content:'';}abbr,acronym{border:0;font-variant:normal;}sup{vertical-align:baseline;}sub{vertical-align:baseline;}legend{color:#000;}input,button,textarea,select,optgroup,option{font-family:inherit;font-size:inherit;font-style:inherit;font-weight:inherit;}input,button,textarea,select{*font-size:100%;}body{font:13px/1.231 arial,helvetica,clean,sans-serif;*font-size:small;*font:x-small;}select,input,button,textarea,button{font:99% arial,helvetica,clean,sans-serif;}table{font-size:inherit;font:100%;}pre,code,kbd,samp,tt{font-family:monospace;*font-size:108%;line-height:100%;}body{text-align:center;}#doc,#doc2,#doc3,#doc4,.yui-t1,.yui-t2,.yui-t3,.yui-t4,.yui-t5,.yui-t6,.yui-t7{margin:auto;text-align:left;width:57.69em;*width:56.25em;}#doc2{width:73.076em;*width:71.25em;}#doc3{margin:auto 10px;width:auto;}#doc4{width:74.923em;*width:73.05em;}.yui-b{position:relative;}.yui-b{_position:static;}#yui-main .yui-b{position:static;}#yui-main,.yui-g .yui-u .yui-g{width:100%;}.yui-t1 #yui-main,.yui-t2 #yui-main,.yui-t3 #yui-main{float:right;margin-left:-25em;}.yui-t4 #yui-main,.yui-t5 #yui-main,.yui-t6 #yui-main{float:left;margin-right:-25em;}.yui-t1 .yui-b{float:left;width:12.30769em;*width:12.00em;}.yui-t1 #yui-main .yui-b{margin-left:13.30769em;*margin-left:13.05em;}.yui-t2 .yui-b{float:left;width:13.8461em;*width:13.50em;}.yui-t2 #yui-main .yui-b{margin-left:14.8461em;*margin-left:14.55em;}.yui-t3 .yui-b{float:left;width:23.0769em;*width:22.50em;}.yui-t3 #yui-main .yui-b{margin-left:24.0769em;*margin-left:23.62em;}.yui-t4 .yui-b{float:right;width:13.8456em;*width:13.50em;}.yui-t4 #yui-main .yui-b{margin-right:14.8456em;*margin-right:14.55em;}.yui-t5 .yui-b{float:right;width:18.4615em;*width:18.00em;}.yui-t5 #yui-main .yui-b{margin-right:19.4615em;*margin-right:19.125em;}.yui-t6 .yui-b{float:right;width:23.0769em;*width:22.50em;}.yui-t6 #yui-main .yui-b{margin-right:24.0769em;*margin-right:23.62em;}.yui-t7 #yui-main .yui-b{display:block;margin:0 0 1em 0;}#yui-main .yui-b{float:none;width:auto;}.yui-gb .yui-u,.yui-g .yui-gb .yui-u,.yui-gb .yui-g,.yui-gb .yui-gb,.yui-gb .yui-gc,.yui-gb .yui-gd,.yui-gb .yui-ge,.yui-gb .yui-gf,.yui-gc .yui-u,.yui-gc .yui-g,.yui-gd .yui-u{float:left;}.yui-g .yui-u,.yui-g .yui-g,.yui-g .yui-gb,.yui-g .yui-gc,.yui-g .yui-gd,.yui-g .yui-ge,.yui-g .yui-gf,.yui-gc .yui-u,.yui-gd .yui-g,.yui-g .yui-gc .yui-u,.yui-ge .yui-u,.yui-ge .yui-g,.yui-gf .yui-g,.yui-gf .yui-u{float:right;}.yui-g div.first,.yui-gb div.first,.yui-gc div.first,.yui-gd div.first,.yui-ge div.first,.yui-gf div.first,.yui-g .yui-gc div.first,.yui-g .yui-ge div.first,.yui-gc div.first div.first{float:left;}.yui-g .yui-u,.yui-g .yui-g,.yui-g .yui-gb,.yui-g .yui-gc,.yui-g .yui-gd,.yui-g .yui-ge,.yui-g .yui-gf{width:49.1%;}.yui-gb .yui-u,.yui-g .yui-gb .yui-u,.yui-gb .yui-g,.yui-gb .yui-gb,.yui-gb .yui-gc,.yui-gb .yui-gd,.yui-gb .yui-ge,.yui-gb .yui-gf,.yui-gc .yui-u,.yui-gc .yui-g,.yui-gd .yui-u{width:32%;margin-left:1.99%;}.yui-gb .yui-u{*margin-left:1.9%;*width:31.9%;}.yui-gc div.first,.yui-gd .yui-u{width:66%;}.yui-gd div.first{width:32%;}.yui-ge div.first,.yui-gf .yui-u{width:74.2%;}.yui-ge .yui-u,.yui-gf div.first{width:24%;}.yui-g .yui-gb div.first,.yui-gb div.first,.yui-gc div.first,.yui-gd div.first{margin-left:0;}.yui-g .yui-g .yui-u,.yui-gb .yui-g .yui-u,.yui-gc .yui-g .yui-u,.yui-gd .yui-g .yui-u,.yui-ge .yui-g .yui-u,.yui-gf .yui-g .yui-u{width:49%;*width:48.1%;*margin-left:0;}.yui-g .yui-g .yui-u{width:48.1%;}.yui-g .yui-gb div.first,.yui-gb .yui-gb div.first{*margin-right:0;*width:32%;_width:31.7%;}.yui-g .yui-gc div.first,.yui-gd .yui-g{width:66%;}.yui-gb .yui-g div.first{*margin-right:4%;_margin-right:1.3%;}.yui-gb .yui-gc div.first,.yui-gb .yui-gd div.first{*margin-right:0;}.yui-gb .yui-gb .yui-u,.yui-gb .yui-gc .yui-u{*margin-left:1.8%;_margin-left:4%;}.yui-g .yui-gb .yui-u{_margin-left:1.0%;}.yui-gb .yui-gd .yui-u{*width:66%;_width:61.2%;}.yui-gb .yui-gd div.first{*width:31%;_width:29.5%;}.yui-g .yui-gc .yui-u,.yui-gb .yui-gc .yui-u{width:32%;_float:right;margin-right:0;_margin-left:0;}.yui-gb .yui-gc div.first{width:66%;*float:left;*margin-left:0;}.yui-gb .yui-ge .yui-u,.yui-gb .yui-gf .yui-u{margin:0;}.yui-gb .yui-gb .yui-u{_margin-left:.7%;}.yui-gb .yui-g div.first,.yui-gb .yui-gb div.first{*margin-left:0;}.yui-gc .yui-g .yui-u,.yui-gd .yui-g .yui-u{*width:48.1%;*margin-left:0;}.yui-gb .yui-gd div.first{width:32%;}.yui-g .yui-gd div.first{_width:29.9%;}.yui-ge .yui-g{width:24%;}.yui-gf .yui-g{width:74.2%;}.yui-gb .yui-ge div.yui-u,.yui-gb .yui-gf div.yui-u{float:right;}.yui-gb .yui-ge div.first,.yui-gb .yui-gf div.first{float:left;}.yui-gb .yui-ge .yui-u,.yui-gb .yui-gf div.first{*width:24%;_width:20%;}.yui-gb .yui-ge div.first,.yui-gb .yui-gf .yui-u{*width:73.5%;_width:65.5%;}.yui-ge div.first .yui-gd .yui-u{width:65%;}.yui-ge div.first .yui-gd div.first{width:32%;}#hd:after,#bd:after,#ft:after,.yui-g:after,.yui-gb:after,.yui-gc:after,.yui-gd:after,.yui-ge:after,.yui-gf:after{content:".";display:block;height:0;clear:both;visibility:hidden;}#hd,#bd,#ft,.yui-g,.yui-gb,.yui-gc,.yui-gd,.yui-ge,.yui-gf{zoom:1;}

body{margin:10px;}h1{font-size:138.5%;}h2{font-size:123.1%;}h3{font-size:108%;}h1,h2,h3{margin:1em 0;}h1,h2,h3,h4,h5,h6,strong,dt{font-weight:bold;}optgroup{font-weight:normal;}abbr,acronym{border-bottom:1px dotted #000;cursor:help;}em{font-style:italic;}del{text-decoration:line-through;}blockquote,ul,ol,dl{margin:1em;}ol,ul,dl{margin-left:2em;}ol li{list-style:decimal outside;}ul li{list-style:disc outside;}dl dd{margin-left:1em;}th,td{border:1px solid #000;padding:.5em;}th{font-weight:bold;text-align:center;}caption{margin-bottom:.5em;text-align:center;}sup{vertical-align:super;}sub{vertical-align:sub;}p,fieldset,table,pre{margin-bottom:1em;}button,input[type="checkbox"],input[type="radio"],input[type="reset"],input[type="submit"]{padding:1px;}
    



/* Ruff default CSS */

h1,h2 {
  color: #888888;
  margin-bottom: 0.5em;
}

#ft {
    text-align: left;
    border-top: 1px solid #006666;
    color: #888888;
    margin-top: 10px;
}

.banner h2 {
    color: #006666;
}

#hd.banner {
 font-family: Trebuchet MS, Helvetica, sans-serif;
 font-weight: bold;
 font-size: 200%;
 line-height: 64px;
 border-bottom: thin solid #006666;
 color: #006666;
}


p.linkline {
    text-align: right;
    font-size: smaller;
/*    margin-top: -1em; */
    margin-bottom: 0;
}

#bd {
  font-family: Verdana;
  font-size: 108%;
}

.linkbox h2 {
  color: #177f75; /* #21b6a8; */
  margin-bottom: 0.2em;
  margin-top: 1.5em;
  font-size: 93%;
}

.linkbox {
  font-size: 93%;
}

.linkbox ul {
  margin-top: 0em;
  margin-left: 0.5em;
}

.linkbox ul li {
  list-style: none;
}

.linkbox a {
  color: #177f75;
  text-decoration: none;
}

.linkbox li a:hover {
  font-weight: bold;
}

div.navbox {
    margin-top: 1em;
    color: #006666;
}

/* Note .navbox header css should be based on $header_levels */
.navbox h1, .navbox h2, .navbox h3, .navbox h4, .navbox h5 {
  font-size: 85%;
  margin: 0px;
}
.navbox h1, .navbox h2, .navbox h3 {
    font-weight: bold;
}
.navbox h1 {
    background-color: #006666;
}
.navbox h2 {
    margin-left: 0.75em;
}
.navbox h3 {
    margin-left: 1.5em;
}
.navbox h4 {
    margin-left: 1.5em;
    font-weight: normal;
}
.navbox h5 {
    margin-left: 2em;
    font-weight: normal;
}

.navbox a:link, .navbox a:visited {
  text-decoration: none;
  color: #006666;
}

.navbox a:hover {
   font-weight: bold;
}

.navbox h1 a:link, .navbox h1 a:visited {
    color: white;
}
/* Easy CSS Tooltip - by Koller Juergen [www.kollermedia.at] */
.navbox a:hover {background:#ffffff; text-decoration:none;} /*BG color is a must for IE6*/
.navbox a.tooltip span {display:none; padding:2px 3px; margin-left:8px; width: 100%;}
/* .navbox a.tooltip span {display:none; padding:2px 3px; margin-left:8px; width:130px;} */
.navbox a.tooltip:hover span{display:inline; position:absolute; border:1px solid #cccccc; background:#ffffff; color:#6c6c6c;}
.navbox h1 a:hover {background: #006666;}

span.ns_scope {
    color: #aaaaaa;
}

span.ns_scope a:link, span.ns_scope a:visited {
  text-decoration: none;
  color: #aaaaaa;

}

span.ns_scope a:hover {
  text-decoration: none;
  color: #666666;
}

table {
  margin: 1em;
  border: thin solid;
  border-collapse: collapse;
  border-color: #808080;
  padding: 4;
}

td {
  border: thin solid;
  border-color: #808080;
  vertical-align: top;
  font-size: 93%;
}
th {
  border: thin solid;
  border-color: #808080;
  padding: 4px;
  background-color: #CCCCCC;
}

dt, dd {
   font-size: 93%;
}

h1.ruff {
    background-color: #006666;
    color: #ffffff;
}
h2.ruff {
    font-variant: small-caps;
    color: #006666;
}

h3.ruff, h4.ruff, h5.ruff {
    border-bottom: thin solid #006666;
    color: #006666;
    margin-bottom: 0em;
}

h6.ruff {
    color: #666666;
}

.ruff_synopsis {
    border: thin solid #cccccc;
    background: #eeeeee;
    font-size: smaller;
    font-family: "Courier New", Courier, monospace;
    padding: 5px;
    margin: 0px 50px 20px;
}
.ruff_const, .ruff_cmd, ruff_defitem {
    font-weight: bold;
    font-family: "Courier New", Courier, monospace;
}
.ruff_arg {
    font-style: italic;
}

.ruff_dyn_src {
    background-color: #eeeeee;
    padding: 5px;
    display: none;
}

    
</style>
<script>
function toggleSource( id )
    {
        /* Copied from Rails */
        var elem
        var link

        if( document.getElementById )
        {
            elem = document.getElementById( id )
            link = document.getElementById( "l_" + id )
        }
        else if ( document.all )
        {
            elem = eval( "document.all." + id )
            link = eval( "document.all.l_" + id )
        }
        else
        return false;

        if( elem.style.display == "block" )
        {
            elem.style.display = "none"
            link.innerHTML = "Show source"
        }
        else
        {
            elem.style.display = "block"
            link.innerHTML = "Hide source"
        }
    }
</script></head><body><div id='doc3' class='yui-t2'><div id='hd' class='banner'>
Ruff! - Runtime Formatting Function Reference (V0.4)
</div>
<div id='bd'><div id='yui-main'><div class='yui-b'><a name='_top'></a><h1 class='ruff'><a name='::ruff'>::ruff</a></h1>
<h2 class='ruff'><a name='Introduction'>Introduction</a></h2>
<p class='ruff'>Ruff! generates reference documentation for Tcl programs using runtime introspection.</p>
<p class='ruff'>Unlike most source code based documentation generators, Ruff! generates documentation using Tcl's runtime system to extract proc, class and method definitions. The code for procedures and methods is parsed to extract documentation from free-form comments. Tcl introspection is used to retrieve information about namespaces, inheritance graphs, default parameter values and so on.</p>
<p class='ruff'>This document contains reference material for Ruff!. For more introductory and tutorial documentation, a user guide is available at <a href='http://woof.magicsplat.com/ruff_guide'>http://woof.magicsplat.com/ruff_guide</a>. The SourceForge site <a href='http://sourceforge.net/projects/woof'>http://sourceforge.net/projects/woof</a> hosts the Ruff! source tree as part of the Woof! project.</p>
<h2 class='ruff'><a name='Usage'>Usage</a></h2>
<p class='ruff'>Ruff! is not intended to be a standalone script. Rather the package provides commands that should be driven from a script that controls which particular namespaces, classes etc. are to be included. Include the following command to load the package into your script.</p>
<pre class='ruff'>
    package require ruff
</pre>
<p class='ruff'>Once loaded, you can use the <a href='#::ruff::document_namespaces'>::ruff::document_namespaces</a> command to document classes and commands within a namespace. For more flexibility in controlling what is to be documented, use the <a href='#::ruff::extract'>::ruff::extract</a> command and pass its results to the  <a href='#::ruff::document'>::ruff::document</a> command.</p>
<p class='ruff'>In the simple case, where only the namespace '::NS' and its children are to be documented, the following commands will create the file 'NS.html' using the built-in HTML formatter.</p>
<pre class='ruff'>
  package require ruff
  ::ruff::document_namespaces html [list ::NS] -output NS.html -recurse true
</pre>
<p class='ruff'>Other commands in the package are intended to be used if you want to roll your own custom formatting package.</p>
<p class='ruff'>Refer to the source code of the command <a href='#::ruff::document_self'>::ruff::document_self</a>, which generates documentation for Ruff!, for an example of how the package might be used.</p>
<h2 class='ruff'><a name='Input format'>Input format</a></h2>
<p class='ruff'>Ruff! extracts documentation from proc and class definitions and comments within the proc and method bodies. The comments are expected to have some simple structure but no extraneous markup is required.</p>
<p class='ruff'>The lines within the body of a proc or method are first filtered as described in documentation for the <a href='#::ruff::distill_body'>::ruff::distill_body</a> command. These lines are then parsed as described in the <a href='#::ruff::parse'>::ruff::parse</a> command to extract different documentation components.</p>
<p class='ruff'>Refer to those commands for the syntax and comment structure expected by Ruff!.</p>
<h2 class='ruff'><a name='Output formats'>Output formats</a></h2>
<p class='ruff'>Ruff! supports multiple output formats. HTML can be directly generated using the internal formatter which does not require any other external tool.</p>
<p class='ruff'>Alternatively, the output can also be generated in a format that is suitable to be fed to an external formatting program such as robodoc or doctools. The command <a href='#::ruff::formatters'>::ruff::formatters</a> returns a list of supported formatters. These formatters in turn can produce documents in several different formats such as html, latex and docbook.</p>
<p class='ruff'>It is recommended that for HTML output, the built-in html formatter be used as it has the best support for cross-referencing, automatic link generation and navigation.</p>
<h2 class='ruff'><a name='::ruff-Commands'>Commands</a></h2>
<h4 class='ruff'><a name='::ruff::distill_body'>distill_body</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a procedure or method body, returns the documentation lines as a list.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>distill_body</span> <span class='ruff_arg'>text</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>text</span></td><td class='ruff_defitem'> text to be processed to collect all documentation lines.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a procedure or method body, returns the documentation lines as a list.</p>
<p class='ruff'>The first block of contiguous comment lines preceding the first line of code are treated as documentation lines.</p>
<p class='ruff'>The string #ruff at the beginning of a comment line anywhere in the passed in text is considered the start of a documentation block. All subsequent contiguous comment lines are considered documentation lines.</p>
<p class='ruff'>Note a #ruff on a line by itself will terminate the previous text block. If #ruff is followed by additional text on the same line, it is treated as a continuation of the previous text block.</p>
<p class='ruff'>The leading comment character and a single space (if present) are trimmed from the returned lines.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_42' href="javascript:toggleSource('42')">Show source</a></p>
<div id='42' class='ruff_dyn_src'><pre>
proc ::ruff::distill_body {text} {

    # Given a procedure or method body,
    # returns the documentation lines as a list.
    # text - text to be processed to collect all documentation lines.
    # The first block of contiguous comment lines preceding the
    # first line of code are treated as documentation lines.

    set lines {}
    set state init;             # init, collecting or searching
    foreach line [split $text \n] {
        set line [string trim $line]; # Get rid of whitespace
        if {$line eq &quot;&quot;} {
            # Blank lines.
            # If in init state, we will stay in init state
            if {$state ne &quot;init&quot;} {
                set state searching
            }
            continue
        }

        if {[string index $line 0] ne &quot;#&quot;} {
            # Not a comment
            set state searching
            continue
        }

        # At this point, the line is a comment line
        if {$state eq &quot;searching&quot;} {
            #ruff
            # The string #ruff at the beginning of a comment line
            # anywhere in the passed in text is considered the start
            # of a documentation block. All subsequent contiguous
            # comment lines are considered documentation lines.
            if {[string match &quot;#ruff*&quot; $line]} {
                set state collecting
                #ruff
                # Note a #ruff on a line by itself will terminate
                # the previous text block.
                set line [string trimright $line]
                if {$line eq &quot;#ruff&quot;} {
                    lappend lines {}
                } else {
                    #ruff If #ruff is followed by additional text
                    # on the same line, it is treated as a continuation
                    # of the previous text block.
                    lappend lines [string range $line 6 end]
                }
            }
        } else {
            # State is init or collecting

            if {$line eq &quot;#&quot;} {
                # Empty comment line
                lappend lines {}
                continue;       # No change in state
            }

            #ruff
            # The leading comment character and a single space (if present)
            # are trimmed from the returned lines.
            if {[string index $line 1] eq &quot; &quot;} {
                lappend lines [string range $line 2 end]
            } else {
                lappend lines [string range $line 1 end]
            }
            set state collecting
            continue
        }
    }

    # Returns a list of lines that comprise the raw documentation.
    return $lines
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::distill_docstring'>distill_docstring</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Splits a documentation string to return the documentation lines as a list.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>distill_docstring</span> <span class='ruff_arg'>text</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>text</span></td><td class='ruff_defitem'> documentation string to be parsed</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Splits a documentation string to return the documentation lines as a list.</p>
<p class='ruff'>Initial blank lines are skipped and multiple empty lines are compressed into one empty line.</p>
<p class='ruff'>The very first non empty line determines the margin. This will be removed from all subsequent lines. Note that this assumes that if tabs are used for indentation, they are used on all lines in consistent fashion.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_43' href="javascript:toggleSource('43')">Show source</a></p>
<div id='43' class='ruff_dyn_src'><pre>
proc ::ruff::distill_docstring {text} {

    # Splits a documentation string to return the documentation lines
    # as a list.
    # text - documentation string to be parsed


    set lines {}
    set state init
    foreach line [split $text \n] {
        if {[regexp {^\s*$} $line]} {
            #ruff
            # Initial blank lines are skipped and
            # multiple empty lines are compressed into one empty line.
            if {$state eq &quot;collecting&quot;} {
                lappend lines &quot;&quot;
                set state empty
            }
            continue
        }
        #ruff
        # The very first non empty line determines the margin. This will
        # be removed from all subsequent lines. Note that this assumes that
        # if tabs are used for indentation, they are used on all lines
        # in consistent fashion.
        if {$state eq &quot;init&quot;} {
            regexp {^(\s*)\S} $line dontcare prefix
            set prefix_len [string length $prefix]
        }
        set state collecting

        # Remove the prefix if it exists from the line
        if {[string match ${prefix}* $line]} {
            set line [string range $line $prefix_len end]
        }

        lappend lines $line
    }

    # Returns a list of lines.
    return $lines
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::document'>document</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Generates documentation for the specified namespaces using the specified formatter.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>document</span> <span class='ruff_arg'>formatter</span> <span class='ruff_arg'>classprocinfodict</span> <span class='ruff_arg'>docstrings</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>formatter</span></td><td class='ruff_defitem'> the formatter to be used to produce the documentation</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classprocinfodict</span></td><td class='ruff_defitem'> dictionary containing the metainformation for  classes and procs for which documentation is to be generated. This  must be in the format returned by the <a href='#::ruff::extract'>extract</a> command.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>docstrings</span></td><td class='ruff_defitem'>(optional, default <span class='ruff_const'></span>)  a flat list of pairs consisting of a heading and    corresponding content. These are inserted into the <a href='#::ruff::document'>document</a>    before the actual class and command descriptions after being    processed by <a href='#::ruff::extract_docstring'>extract_docstring</a>.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the documentation string as generated by the specified formatter.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Generates documentation for the specified namespaces using the specified formatter.</p>
<p class='ruff'>All additional arguments are passed through to the specified formatter's generate_document command.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_44' href="javascript:toggleSource('44')">Show source</a></p>
<div id='44' class='ruff_dyn_src'><pre>
proc ::ruff::document {formatter classprocinfodict {docstrings {}} args} {

    # Generates documentation for the specified namespaces using the
    # specified formatter.
    # formatter - the formatter to be used to produce the documentation
    # classprocinfodict - dictionary containing the metainformation for
    #  classes and procs for which documentation is to be generated. This
    #  must be in the format returned by the extract command.
    # docstrings - a flat list of pairs consisting of a heading and
    #    corresponding content. These are inserted into the document
    #    before the actual class and command descriptions after being
    #    processed by extract_docstring.
    #
    # All additional arguments are passed through to the specified
    # formatter's generate_document command.
    #
    # Returns the documentation string as generated by the specified formatter.

    _load_formatter $formatter

    set preamble [dict create]
    foreach {sec docstring} $docstrings {
        # Treate the preamble as a &quot;toplevel&quot; preamble
        dict lappend preamble &quot;::&quot; $sec [extract_docstring $docstring]
    }

    return [eval [list [namespace current]::formatter::${formatter}::generate_document $classprocinfodict -preamble $preamble] $args]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::document_namespace'>document_namespace</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Obsolete, use <a href='#::ruff::document_namespaces'>document_namespaces</a> instead.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>document_namespace</span> <span class='ruff_arg'>formatter</span> <span class='ruff_arg'>ns</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>formatter</span></td><td class='ruff_defitem'></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>ns</span></td><td class='ruff_defitem'></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Obsolete, use <a href='#::ruff::document_namespaces'>document_namespaces</a> instead.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_45' href="javascript:toggleSource('45')">Show source</a></p>
<div id='45' class='ruff_dyn_src'><pre>
proc ::ruff::document_namespace {formatter ns args} {

    # Obsolete, use document_namespaces instead.
    return [eval [list document_namespaces $formatter [list $ns] -title $ns] $args]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::document_namespaces'>document_namespaces</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Generates documentation for the specified namespaces using the specified formatter.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>document_namespaces</span> <span class='ruff_arg'>formatter</span> <span class='ruff_arg'>namespaces</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>formatter</span></td><td class='ruff_defitem'> the formatter to be used to produce the documentation</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>namespaces</span></td><td class='ruff_defitem'> list of namespaces for which documentation is to be generated</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-append BOOLEAN</span></td><td class='ruff_defitem'> if true, the generated <a href='#::ruff::document'>document</a> is appended  to the specified file instead of overwriting it.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includeclasses BOOLEAN</span></td><td class='ruff_defitem'> if true (default), class information     is collected</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includeprivate BOOLEAN</span></td><td class='ruff_defitem'> if true private methods are also included  in the generated documentation. Default is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includeprocs BOOLEAN</span></td><td class='ruff_defitem'> if true (default), proc information is     collected</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the  procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-output PATH</span></td><td class='ruff_defitem'> if specified, the generated <a href='#::ruff::document'>document</a> is written  to the specified file which will overwritten if it already exists.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-recurse BOOLEAN</span></td><td class='ruff_defitem'> if true, child namespaces are recursively  documented.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-title STRING</span></td><td class='ruff_defitem'> specifies the title to use for the page</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the documentation string if the -output option is not specified, otherwise returns an empty string after writing the documentation to the specified file.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Generates documentation for the specified namespaces using the specified formatter.</p>
<p class='ruff'>Any additional arguments are passed through to the <a href='#::ruff::document'>document</a> command.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_46' href="javascript:toggleSource('46')">Show source</a></p>
<div id='46' class='ruff_dyn_src'><pre>
proc ::ruff::document_namespaces {formatter namespaces args} {

    # Generates documentation for the specified namespaces using the
    # specified formatter.
    # formatter - the formatter to be used to produce the documentation
    # namespaces - list of namespaces for which documentation is to be generated
    # -includeclasses BOOLEAN - if true (default), class information
    #     is collected
    # -includeprocs BOOLEAN - if true (default), proc information is
    #     collected
    # -includeprivate BOOLEAN - if true private methods are also included
    #  in the generated documentation. Default is false.
    # -includesource BOOLEAN - if true, the source code of the
    #  procedure is also included. Default value is false.
    # -output PATH - if specified, the generated document is written
    #  to the specified file which will overwritten if it already exists.
    # -append BOOLEAN - if true, the generated document is appended
    #  to the specified file instead of overwriting it.
    # -title STRING - specifies the title to use for the page
    # -recurse BOOLEAN - if true, child namespaces are recursively
    #  documented.
    #
    # Any additional arguments are passed through to the document command.
    #
    # Returns the documentation string if the -output option is not
    # specified, otherwise returns an empty string after writing the
    # documentation to the specified file.

    array set opts {
        -includeclasses true
        -includeprocs true
        -includeprivate false
        -includesource false
        -output &quot;&quot;
        -append false
        -title &quot;&quot;
        -recurse false
    }
    array set opts $args

    if {$opts(-recurse)} {
        set namespaces [_namespace_tree $namespaces]
    }

    set preamble [dict create]
    foreach ns $namespaces {
        if {[info exists ${ns}::_ruffdoc]} {
            foreach {section docstring} [set ${ns}::_ruffdoc] {
                dict lappend preamble $ns $section [extract_docstring $docstring]
            }
        }
    }

    set classprocinfodict [extract_namespaces $namespaces  -includeclasses $opts(-includeclasses)  -includeprocs $opts(-includeprocs)  -includeprivate $opts(-includeprivate)]

    _load_formatter $formatter
    set doc  [eval  [list formatter::${formatter}::generate_document  $classprocinfodict  -preamble $preamble  -modulename $opts(-title)  ]  $args]
    if {$opts(-output) ne &quot;&quot;} {
        if {$opts(-append)} {
            set fd [open $opts(-output) a]
        } else {
            set fd [open $opts(-output) w]
        }
        if {[catch {
            puts $fd $doc
        } msg]} {
            close $fd
            error $msg
        }
        close $fd
        return
    } else {
        return $doc
    }
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::document_self'>document_self</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Generates documentation for Ruff!</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>document_self</span> <span class='ruff_arg'>formatter</span> <span class='ruff_arg'>output_dir</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>formatter</span></td><td class='ruff_defitem'> the formatter to use</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>output_dir</span></td><td class='ruff_defitem'> the output directory where files will be stored. Note  files in this directory with the same name as the output files  will be overwritten!</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-formatterpath PATH</span></td><td class='ruff_defitem'> path to the formatter. If unspecified, the  the input files for the formatter are generated but the formatter  is not run. This option is ignore for the built-in HTML formatter.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, include source code in documentation.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Generates documentation for Ruff!</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_47' href="javascript:toggleSource('47')">Show source</a></p>
<div id='47' class='ruff_dyn_src'><pre>
proc ::ruff::document_self {formatter output_dir args} {

    # Generates documentation for Ruff!
    # formatter - the formatter to use
    # output_dir - the output directory where files will be stored. Note
    #  files in this directory with the same name as the output files
    #  will be overwritten!
    # -formatterpath PATH - path to the formatter. If unspecified, the
    #  the input files for the formatter are generated but the formatter
    #  is not run. This option is ignore for the built-in HTML formatter.
    # -includesource BOOLEAN - if true, include source code in documentation.

    variable names

    array set opts {
        -formatterpath &quot;&quot;
        -includesource FALSE
    }
    array set opts $args

    _load_all_formatters;       # So all will be documented!

    set modules [dict create]
    # Enumerate and set the descriptive text for all the modules.
    # TBD - use these settings to generate preambles for the modules
    dict set modules ::ruff  [dict create description &quot;$names(display) main module&quot;]
    dict set modules ::ruff::formatter  [dict create description &quot;$names(display) formatters&quot;]
    dict set modules ::ruff::formatter::doctools  [dict create description &quot;$names(display) formatter for Doctools&quot;]
    dict set modules ::ruff::formatter::naturaldocs  [dict create description &quot;$names(display) formatter for NaturalDocs&quot;]
    dict set modules ::ruff::formatter::robodoc  [dict create description &quot;$names(display) formatter for ROBODoc&quot;]
    dict set modules ::ruff::formatter::html  [dict create description &quot;$names(display) formatter for HTML&quot;]
    dict set modules ::ruff::app  [dict create description &quot;$names(display) application callbacks&quot;]

    file mkdir $output_dir
    if {$formatter ne &quot;html&quot;} {
        # For external formatters, we need input and output directories
        set outdir [file join $output_dir output]
        set indir  [file join $output_dir Ruff]
        file mkdir $indir;  # Input for formatter, output for us!
        file mkdir $outdir
    }
    switch -exact -- $formatter {
        naturaldocs {
            set projdir [file join $output_dir proj]
            file mkdir $projdir
            dict for {ns nsdata} $modules {
                set fn [string map {:: _} [string trimleft $ns :]]
                set fn &quot;[file join $indir $fn].tcl&quot;
                document_namespace naturaldocs $ns -output $fn -hidenamespace $ns
            }
            # We want to change the stylesheet for NaturalDocs
            set fd [open [file join $projdir ruff.css] w]
            puts $fd &quot;p { text-indent: 0; margin-bottom: 1em; }&quot;
            puts $fd &quot;blockquote {margin-left: 5em;}&quot;
            close $fd
            if {$opts(-formatterpath) ne &quot;&quot;} {
                if {[catch {
                    eval exec $opts(-formatterpath) [list --input $indir  --output HTML $outdir  --project $projdir  --rebuild  --style Default ruff  ]
                } msg]} {
                    app::log_error &quot;Error executing NaturalDocs using path '$opts(-formatterpath)': $msg&quot;
                }
            }
        }
        doctools {
            dict for {ns nsdata} $modules {
                set fn [string map {:: _} [string trimleft $ns :]]
                set fn &quot;[file join $indir $fn].man&quot;
                document_namespace doctools $ns -output $fn -hidenamespace $ns  -name $ns  -keywords [list &quot;documentation generation&quot;]  -modulename $ns  -titledesc [dict get $nsdata description]  -version $::ruff::version
            }
            if {$opts(-formatterpath) ne &quot;&quot;} {
                if {[catch {
                    eval exec $opts(-formatterpath) [list -o $outdir html $indir]
                } msg]} {
                    app::log_error &quot;Error executing doctools using path '$opts(-formatterpath)': $msg&quot;
                }
            }
        }
        html {
            # Note here we use $output_dir since will directly produce HTML
            # and not intermediate files
            document_namespaces html ::ruff -recurse true  -output [file join $output_dir ruff.html]  -titledesc &quot;Ruff! - Runtime Formatting Function Reference (V$::ruff::version)&quot;  -copyright &quot;[clock format [clock seconds] -format %Y] Ashok P. Nadkarni&quot;  -includesource $opts(-includesource)
        }
        default {
            # The formatter may exist but we do not support it for
            # out documentation.
            error &quot;Formatter '$formatter' not implemented for generating Ruff! documentation.&quot;
        }
    }
    return
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::extract'>extract</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Extracts metainformation for procs and classes</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>extract</span> <span class='ruff_arg'>pattern</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>pattern</span></td><td class='ruff_defitem'> glob-style pattern to match against procedure and class names</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includeclasses BOOLEAN</span></td><td class='ruff_defitem'> if true (default), class information     is collected</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includeimports BOOLEAN</span></td><td class='ruff_defitem'> if true commands imported from other  namespaces are also included. Default is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includeprivate BOOLEAN</span></td><td class='ruff_defitem'> if true private methods are also included.  Default is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includeprocs</span></td><td class='ruff_defitem'> if true (default), proc information is     collected</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns a dictionary with keys 'classes' and 'procs'</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Extracts metainformation for procs and classes</p>
<p class='ruff'>The value of the classes key in the returned dictionary is a dictionary whose keys are class names and whose corresponding values are in the format returned by <a href='#::ruff::extract_ooclass'>extract_ooclass</a>. Similarly, the procs key contains a dictionary whose keys are proc names and whose corresponding values are in the format as returned by <a href='#::ruff::extract_proc'>extract_proc</a>.</p>
<p class='ruff'>Note that only the program elements in the same namespace as the namespace of $pattern are returned.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_48' href="javascript:toggleSource('48')">Show source</a></p>
<div id='48' class='ruff_dyn_src'><pre>
proc ::ruff::extract {pattern args} {

    # Extracts metainformation for procs and classes
    #
    # pattern - glob-style pattern to match against procedure and class names
    # -includeclasses BOOLEAN - if true (default), class information
    #     is collected
    # -includeprocs - if true (default), proc information is
    #     collected
    # -includeprivate BOOLEAN - if true private methods are also included.
    #  Default is false.
    #
    # The value of the classes key in the returned dictionary is
    # a dictionary whose keys are class names and whose corresponding values
    # are in the format returned by extract_ooclass.
    # Similarly, the procs key contains a dictionary whose keys
    # are proc names and whose corresponding values are in the format
    # as returned by extract_proc.
    #
    # Note that only the program elements in the same namespace as
    # the namespace of $pattern are returned.
    #
    # Returns a dictionary with keys 'classes' and 'procs'

    array set opts {
        -includeclasses true
        -includeprocs true
        -includeprivate false
        -includeimports false
    }
    array set opts $args

    set classes [dict create]
    if {$opts(-includeclasses)} {
        # We do a catch in case this Tcl version does not support objects
        set class_names {}
        catch {set class_names [info class instances ::oo::class $pattern]}
        foreach class_name $class_names {
            # This covers child namespaces as well which we do not want
            # so filter those out. The differing pattern interpretations in
            # Tcl commands 'info class instances' and 'info procs'
            # necessitates this.
            if {[namespace qualifiers $class_name] ne [namespace qualifiers $pattern]} {
                # Class is in not in desired namespace
                # TBD - do we need to do -includeimports processing here?
                continue
            }
            # Names beginning with _ are treated as private
            if {(!$opts(-includeprivate)) &amp;&amp;
                [string index [namespace tail $class_name] 0] eq &quot;_&quot;} {
                continue
            }

            if {[catch {
                set class_info [extract_ooclass $class_name -includeprivate $opts(-includeprivate)]
            } msg]} {
                app::log_error &quot;Could not document class $class_name&quot;
            } else {
                dict set classes $class_name $class_info
            }
        }
    }

    set procs [dict create]
    if {$opts(-includeprocs)} {
        foreach proc_name [info procs $pattern] {
            #ruff
            # -includeimports BOOLEAN - if true commands imported from other
            #  namespaces are also included. Default is false.
            if {(! $opts(-includeimports)) &amp;&amp;
                [namespace origin $proc_name] ne $proc_name} {
                continue;       # Do not want to include imported commands
            }
            # Names beginning with _ are treated as private
            if {(!$opts(-includeprivate)) &amp;&amp;
                [string index [namespace tail $proc_name] 0] eq &quot;_&quot;} {
                continue
            }

            if {[catch {
                set proc_info [extract_proc $proc_name]
            } msg]} {
                app::log_error &quot;Could not document proc $proc_name&quot;
            } else {
                dict set procs $proc_name $proc_info
            }
        }
    }

    return [dict create classes $classes procs $procs]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::extract_docstring'>extract_docstring</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Parses a documentation string to return a structured text representation.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>extract_docstring</span> <span class='ruff_arg'>text</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>text</span></td><td class='ruff_defitem'> documentation string to be parsed</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Parses a documentation string to return a structured text representation.</p>
<p class='ruff'>The command extracts structured text from the given string as described in the documentation for the <a href='#::ruff::distill_docstring'>distill_docstring</a> and <a href='#::ruff::parse'>parse</a> commands. The result is further processed to return a list of type and value elements described below:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>deflist</td><td class='ruff_defitem'> the corresponding value is another list containing   definition item name and its value as a string.</td></tr>
<tr><td class='ruff_defitem'>bulletlist</td><td class='ruff_defitem'> the corresponding value is a list of strings   each being one list item.</td></tr>
<tr><td class='ruff_defitem'>paragraph</td><td class='ruff_defitem'> the corresponding value is a string comprising   the paragraph.</td></tr>
<tr><td class='ruff_defitem'>preformatted</td><td class='ruff_defitem'> the corresponding value is a string comprising   preformatted text.</td></tr>
</table>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_49' href="javascript:toggleSource('49')">Show source</a></p>
<div id='49' class='ruff_dyn_src'><pre>
proc ::ruff::extract_docstring {text} {

    # Parses a documentation string to return a structured text representation.
    # text - documentation string to be parsed
    #
    # The command extracts structured text from the given string
    # as described in the documentation for the distill_docstring
    # and parse commands. The result is further processed to
    # return a list of type and value elements described below:
    # deflist - the corresponding value is another list containing
    #   definition item name and its value as a string.
    # bulletlist - the corresponding value is a list of strings
    #   each being one list item.
    # paragraph - the corresponding value is a string comprising
    #   the paragraph.
    # preformatted - the corresponding value is a string comprising
    #   preformatted text.


    set paragraphs {}

    # Loop and construct the documentation
    foreach {type content} [parse [distill_docstring $text]] {
        switch -exact -- $type {
            deflist {
                # Each named list is a list of pairs
                set deflist {}
                foreach {name desc} $content {
                    lappend deflist $name [join $desc &quot; &quot;]
                }
                lappend paragraphs deflist $deflist
            }
            bulletlist {
                # Bullet lists are lumped with paragraphs
                set bulletlist {}
                foreach desc $content {
                    lappend bulletlist [join $desc &quot; &quot;]
                }
                lappend paragraphs bulletlist $bulletlist
            }
            summary {
                # Do nothing. Summaries are same as the first
                # paragraph. For docstrings, we do not show
                # them separately like we do for procs
            }
            paragraph {
                lappend paragraphs paragraph [join $content &quot; &quot;]
            }
            preformatted {
                lappend paragraphs preformatted [join $content \n]
            }
            default {
                error &quot;Text fragments of type '$type' not supported in docstrings&quot;
            }
        }
    }
    return $paragraphs
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::extract_namespace'>extract_namespace</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Extracts metainformation for procs and objects in a namespace</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>extract_namespace</span> <span class='ruff_arg'>ns</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>ns</span></td><td class='ruff_defitem'> namespace to examine</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns a dictionary with keys 'classes' and 'procs'. See ruff::extract for details.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Extracts metainformation for procs and objects in a namespace</p>
<p class='ruff'>Any additional options are passed on to the <a href='#::ruff::extract'>extract</a> command.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_50' href="javascript:toggleSource('50')">Show source</a></p>
<div id='50' class='ruff_dyn_src'><pre>
proc ::ruff::extract_namespace {ns args} {

    # Extracts metainformation for procs and objects in a namespace
    # ns - namespace to examine
    #
    # Any additional options are passed on to the extract command.
    #
    # Returns a dictionary with keys 'classes' and 'procs'. See ruff::extract
    # for details.

    return [eval [list extract ${ns}::*] $args]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::extract_namespaces'>extract_namespaces</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Extracts metainformation for procs and objects in one or more namespace</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>extract_namespaces</span> <span class='ruff_arg'>namespaces</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>namespaces</span></td><td class='ruff_defitem'> list of namespace to examine</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns a dictionary with keys 'classes' and 'procs'. See ruff::extract for details.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Extracts metainformation for procs and objects in one or more namespace</p>
<p class='ruff'>Any additional options are passed on to the <a href='#::ruff::extract_namespace'>extract_namespace</a> command.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_51' href="javascript:toggleSource('51')">Show source</a></p>
<div id='51' class='ruff_dyn_src'><pre>
proc ::ruff::extract_namespaces {namespaces args} {

    # Extracts metainformation for procs and objects in one or more namespace
    # namespaces - list of namespace to examine
    #
    # Any additional options are passed on to the extract_namespace command.
    #
    # Returns a dictionary with keys 'classes' and 'procs'. See ruff::extract
    # for details.

    set procs [dict create]
    set classes [dict create]
    foreach ns $namespaces {
        set nscontent [eval [list extract ${ns}::*] $args]
        set procs   [dict merge $procs [dict get $nscontent procs]]
        set classes [dict merge $classes [dict get $nscontent classes]]
    }
    return [dict create procs $procs classes $classes]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::extract_ooclass'>extract_ooclass</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Extracts metainformation about the specified class</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>extract_ooclass</span> <span class='ruff_arg'>classname</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classname</span></td><td class='ruff_defitem'> name of the class to be documented</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includeprivate BOOLEAN</span></td><td class='ruff_defitem'> if true private methods are also included  in the metainformation. Default is false.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Extracts metainformation about the specified class</p>
<p class='ruff'>The metainformation. returned is in the form of a dictionary with the following keys:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>name</td><td class='ruff_defitem'> name of the class</td></tr>
<tr><td class='ruff_defitem'>methods</td><td class='ruff_defitem'> a list of method definitions for this class in the form  returned by <a href='#::ruff::extract_ooclass_method'>extract_ooclass_method</a> with the additional key  'visibility' which may have values 'public' or 'private'.</td></tr>
<tr><td class='ruff_defitem'>external_methods</td><td class='ruff_defitem'> a list of names of methods that are  either inherited or mixed in</td></tr>
<tr><td class='ruff_defitem'>filters</td><td class='ruff_defitem'> a list of filters defined by the class</td></tr>
<tr><td class='ruff_defitem'>forwards</td><td class='ruff_defitem'> a list of forwarded methods, each element in the  list being a dictionary with keys 'name' and 'forward'  corresponding to the forwarded method name and the forwarding command.</td></tr>
<tr><td class='ruff_defitem'>mixins</td><td class='ruff_defitem'> a list of names of classes mixed into the class</td></tr>
<tr><td class='ruff_defitem'>superclasses</td><td class='ruff_defitem'> a list of names of classes which are direct   superclasses of the class</td></tr>
<tr><td class='ruff_defitem'>subclasses</td><td class='ruff_defitem'> a list of classes which are direct subclasses of this class</td></tr>
<tr><td class='ruff_defitem'>constructor</td><td class='ruff_defitem'> method definition for the constructor in the format   returned by <a href='#::ruff::extract_ooclass_method'>extract_ooclass_method</a></td></tr>
<tr><td class='ruff_defitem'>destructor</td><td class='ruff_defitem'> method definition for the destructor   returned by <a href='#::ruff::extract_ooclass_method'>extract_ooclass_method</a></td></tr>
</table>
<p class='ruff'>Each method definition is in the format returned by the <a href='#::ruff::extract_ooclass_method'>extract_ooclass_method</a> command with an additional keys:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>visibility</td><td class='ruff_defitem'> indicates whether the method is 'public' or 'private'</td></tr>
</table>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_52' href="javascript:toggleSource('52')">Show source</a></p>
<div id='52' class='ruff_dyn_src'><pre>
proc ::ruff::extract_ooclass {classname args} {

    # Extracts metainformation about the specified class
    # classname - name of the class to be documented
    # -includeprivate BOOLEAN - if true private methods are also included
    #  in the metainformation. Default is false.
    #
    # The metainformation. returned is in the form of a dictionary with
    # the following keys:
    # name - name of the class
    # methods - a list of method definitions for this class in the form
    #  returned by extract_ooclass_method with the additional key
    #  'visibility' which may have values 'public' or 'private'.
    # external_methods - a list of names of methods that are
    #  either inherited or mixed in
    # filters - a list of filters defined by the class
    # forwards - a list of forwarded methods, each element in the
    #  list being a dictionary with keys 'name' and 'forward'
    #  corresponding to the forwarded method name and the forwarding command.
    # mixins - a list of names of classes mixed into the class
    # superclasses - a list of names of classes which are direct
    #   superclasses of the class
    # subclasses - a list of classes which are direct subclasses of this class
    # constructor - method definition for the constructor in the format
    #   returned by extract_ooclass_method
    # destructor - method definition for the destructor
    #   returned by extract_ooclass_method
    #
    # Each method definition is in the format returned by the
    # extract_ooclass_method command with an additional keys:
    # visibility - indicates whether the method is 'public' or 'private'

    array set opts {-includeprivate false}
    array set opts $args

    set result [dict create methods {} external_methods {}  filters {} forwards {}  mixins {} superclasses {} subclasses {}  name $classname  ]

    if {$opts(-includeprivate)} {
        set all_local_methods [info class methods $classname -private]
        set all_methods [info class methods $classname -all -private]
    } else {
        set all_local_methods [info class methods $classname]
        set all_methods [info class methods $classname -all]
    }
    set public_methods [info class methods $classname -all]
    set external_methods {}
    foreach name $all_methods {
        set implementing_class [locate_ooclass_method $classname $name]
        if {[lsearch -exact $all_local_methods $name] &lt; 0} {
            # Skip the destroy method which is standard and
            # appears in all classes.
            if {$implementing_class ne &quot;::oo::object&quot; ||
                $name ne &quot;destroy&quot;} {
                lappend external_methods [list $name $implementing_class]
            }
            continue
        }

        # Even if a local method, it may be hidden by a mixin
        if {$implementing_class ne $classname} {
            # TBD - should we make a note in the documentation somewhere ?
            app::log_error &quot;Method $name in class $classname is hidden by class $implementing_class.&quot;
        }

        if {[lsearch -exact $public_methods $name] &gt;= 0} {
            set visibility public
        } else {
            set visibility private
        }

        if {! [catch {
            set method_info [extract_ooclass_method $classname $name]
        } msg]} {
            dict set method_info visibility $visibility
            #dict set method_info name $name
            dict lappend result methods $method_info
        } else {
            # Error, may be it is a forwarded method
            if {! [catch {
                set forward [info class forward $classname $name]
            }]} {
                dict lappend result forwards [dict create name $name forward $forward]
            } else {
                ruff::app::log_error &quot;Could not introspect method $name in class $classname&quot;
            }
        }
    }

    foreach name {constructor destructor} {
        if {[info class $name $classname] ne &quot;&quot;} {
            # Class has non-empty constructor or destructor
            dict set result $name [extract_ooclass_method $classname $name]
        }
    }

    dict set result name $classname;   # TBD - should we fully qualify this?
    dict set result external_methods $external_methods
    dict set result filters [info class filters $classname]
    dict set result mixins [info class mixins $classname]
    dict set result subclasses [info class subclasses $classname]
    # We do not want to list ::oo::object which is a superclass
    # of all classes.
    set classes {}
    foreach class [info class superclasses $classname] {
        if {$class ne &quot;::oo::object&quot;} {
            lappend classes $class
        }
    }
    dict set result superclasses $classes

    return $result
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::extract_ooclass_method'>extract_ooclass_method</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Extracts metainformation for the method in oo:: class</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>extract_ooclass_method</span> <span class='ruff_arg'>class</span> <span class='ruff_arg'>method</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>class</span></td><td class='ruff_defitem'> name of the class</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>method</span></td><td class='ruff_defitem'></td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns a dictionary containing documentation related to the command.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Extracts metainformation for the method in oo:: class</p>
<p class='ruff'>The command retrieves metainformation about a Tcl class method. See the command <a href='#::ruff::extract_proc_or_method'>extract_proc_or_method</a> for details.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_53' href="javascript:toggleSource('53')">Show source</a></p>
<div id='53' class='ruff_dyn_src'><pre>
proc ::ruff::extract_ooclass_method {class method} {


    # Extracts metainformation for the method in oo:: class
    # class - name of the class
    #
    # The command retrieves metainformation about
    # a Tcl class method. See the command extract_proc_or_method
    # for details.
    #
    # Returns a dictionary containing documentation related to the command.
    #


    switch -exact -- $method {
        constructor {
            foreach {params body} [info class constructor $class] break
        }
        destructor  {
            set body [lindex [info class destructor $class] 0]
            set params {}
        }
        default {
            foreach {params body} [info class definition $class $method] break
        }
    }


    set param_names {}
    set param_defaults {}
    foreach param $params {
        lappend param_names [lindex $param 0]
        if {[llength $param] &gt; 1} {
            lappend param_defaults [lindex $param 0] [lindex $param 1]
        }
    }

    return [extract_proc_or_method method $method $param_names $param_defaults $body $class]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::extract_proc'>extract_proc</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Extracts meta information from a Tcl procedure.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>extract_proc</span> <span class='ruff_arg'>procname</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procname</span></td><td class='ruff_defitem'> name of the procedure</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns a dictionary containing metainformation for the command.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Extracts meta information from a Tcl procedure.</p>
<p class='ruff'>The command retrieves metainformation about a Tcl procedure. See the command <a href='#::ruff::extract_proc_or_method'>extract_proc_or_method</a> for details.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_54' href="javascript:toggleSource('54')">Show source</a></p>
<div id='54' class='ruff_dyn_src'><pre>
proc ::ruff::extract_proc {procname} {


    # Extracts meta information from a Tcl procedure.
    # procname - name of the procedure
    #
    # The command retrieves metainformation about
    # a Tcl procedure. See the command extract_proc_or_method
    # for details.
    #
    # Returns a dictionary containing metainformation for the command.
    #

    set param_names [info args $procname]
    set param_defaults {}
    foreach name $param_names {
        if {[info default $procname $name val]} {
            lappend param_defaults $name $val
        }
    }
    return [extract_proc_or_method proc $procname [info args $procname] $param_defaults [info body $procname]]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::extract_proc_or_method'>extract_proc_or_method</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Helper procedure used by <a href='#::ruff::extract_proc'>extract_proc</a> and <a href='#::ruff::extract_ooclass_method'>extract_ooclass_method</a> to construct metainformation for a method or proc.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>extract_proc_or_method</span> <span class='ruff_arg'>proctype</span> <span class='ruff_arg'>procname</span> <span class='ruff_arg'>param_names</span> <span class='ruff_arg'>param_defaults</span> <span class='ruff_arg'>body</span> <span class='ruff_arg'>class</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>proctype</span></td><td class='ruff_defitem'> should be either 'proc' or 'method'</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procname</span></td><td class='ruff_defitem'> name of the proc or method</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>param_names</span></td><td class='ruff_defitem'> list of parameter names in order</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>param_defaults</span></td><td class='ruff_defitem'> list of parameter name and default values</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>body</span></td><td class='ruff_defitem'> the body of the proc or method</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>class</span></td><td class='ruff_defitem'>(optional, default <span class='ruff_const'></span>)  the name of the class to which the method belongs. Not used   for proc types.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Helper procedure used by <a href='#::ruff::extract_proc'>extract_proc</a> and <a href='#::ruff::extract_ooclass_method'>extract_ooclass_method</a> to construct metainformation for a method or proc.</p>
<p class='ruff'>The command parses the $body parameter as described by the <a href='#::ruff::distill_body'>distill_body</a> and <a href='#::ruff::parse'>parse</a> commands and then constructs the metainformation for the proc or method using this along with the other passed arguments. The metainformation is returned as a dictionary with the following keys:</p>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'>name</td><td class='ruff_defitem'> name of the proc or method</td></tr>
<tr><td class='ruff_defitem'>parameters</td><td class='ruff_defitem'> a list of parameters. Each element of the     list is a pair or a triple, consisting of the parameter name,     the description and possibly the default value if there is one.</td></tr>
<tr><td class='ruff_defitem'>options</td><td class='ruff_defitem'> a list of options. Each element is a pair consisting     of the name and its description.</td></tr>
<tr><td class='ruff_defitem'>description</td><td class='ruff_defitem'> a list of paragraphs describing the command. The     list contains preformatted, paragraph, bulletlist and deflist     elements as described for the <a href='#::ruff::extract_docstring'>extract_docstring</a> command.</td></tr>
<tr><td class='ruff_defitem'>return</td><td class='ruff_defitem'> a description of the return value of the command</td></tr>
<tr><td class='ruff_defitem'>summary</td><td class='ruff_defitem'> a copy of the first paragraph if it was present     before the parameter descriptions.</td></tr>
<tr><td class='ruff_defitem'>source</td><td class='ruff_defitem'> the source code of the command</td></tr>
</table>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_55' href="javascript:toggleSource('55')">Show source</a></p>
<div id='55' class='ruff_dyn_src'><pre>
proc ::ruff::extract_proc_or_method {proctype procname param_names param_defaults body {class {}}} {

    # Helper procedure used by extract_proc and extract_ooclass_method to
    # construct metainformation for a method or proc.
    #  proctype - should be either 'proc' or 'method'
    #  procname - name of the proc or method
    #  param_names - list of parameter names in order
    #  param_defaults - list of parameter name and default values
    #  body - the body of the proc or method
    #  class - the name of the class to which the method belongs. Not used
    #   for proc types.
    #
    # The command parses the $body parameter as described by the distill_body
    # and parse commands and then constructs the metainformation for
    # the proc or method using this along with the other passed arguments.
    # The metainformation is returned as a dictionary with the following keys:
    #   name - name of the proc or method
    #   parameters - a list of parameters. Each element of the
    #     list is a pair or a triple, consisting of the parameter name,
    #     the description and possibly the default value if there is one.
    #   options - a list of options. Each element is a pair consisting
    #     of the name and its description.
    #   description - a list of paragraphs describing the command. The
    #     list contains preformatted, paragraph, bulletlist and deflist
    #     elements as described for the extract_docstring command.
    #   return - a description of the return value of the command
    #   summary - a copy of the first paragraph if it was present
    #     before the parameter descriptions.
    #   source - the source code of the command
    #

    array set param_default $param_defaults
    array set params {}
    array set options {}
    set paragraphs {}

    # Loop and construct the documentation
    foreach {type content} [parse [distill_body $body]] {
        switch -exact -- $type {
            parameter {
                # For each parameter, check if it is a
                # parameter in the proc/method definition
                foreach {name desc} $content {
                    if {[lsearch -exact $param_names $name] &gt;= 0} {
                        set params($name) [join $desc &quot; &quot;]
                    } else {
                        #TBD - how to handle this? For now, assume it's
                        #a parameter as well
                        app::log_error &quot;Parameter '$name' not listed in arguments for '$procname'&quot;
                        set params($name) [join $desc &quot; &quot;]
                    }
                }
            }
            summary -
            return {
                set doc($type) [join $content &quot; &quot;]
            }
            deflist {
                # Named lists are lumped with paragraphs
                # Each named list is a list of pairs
                set deflist {}
                foreach {name desc} $content {
                    lappend deflist $name [join $desc &quot; &quot;]
                }
                lappend paragraphs deflist $deflist
            }
            bulletlist {
                # Bullet lists are lumped with paragraphs
                set bulletlist {}
                foreach desc $content {
                    lappend bulletlist [join $desc &quot; &quot;]
                }
                lappend paragraphs bulletlist $bulletlist
            }
            option {
                foreach {name desc} $content {
                    if {[lsearch -exact $param_names &quot;args&quot;] &lt; 0} {
                        app::log_error &quot;Documentation for '$procname' contains option '$name' but the procedure definition does not have an 'args' parameter&quot;
                    }
                    set options($name) [join $desc &quot; &quot;]
                }
            }
            paragraph {
                lappend paragraphs paragraph [join $content &quot; &quot;]
            }
            preformatted {
                lappend paragraphs preformatted [join $content \n]
            }
            default {
                error &quot;Unknown text fragment type '$type'.&quot;
            }
        }
    }

    set doc(name)        $procname
    set doc(class)       $class
    set doc(description) $paragraphs
    set doc(proctype)    $proctype

    # Construct parameter descriptions. Note those not listed in the
    # actual proc definition are left out even if they are in the params
    # table
    set doc(parameters) {}
    foreach name $param_names {
        if {[info exists params($name)]} {
            set paramdata [dict create name $name description $params($name) type parameter]
        } else {
            set paramdata [dict create name $name type parameter]
        }

        # Check if there is a default
        if {[info exists param_default($name)]} {
            dict set paramdata default $param_default($name)
        }

        lappend doc(parameters) $paramdata
    }

    # Add the options into the parameter table
    foreach name [lsort [array names options]] {
        lappend doc(parameters) [dict create name $name description $options($name) type option]
    }

    set source &quot;$proctype $procname &quot;
    set param_list {}
    foreach name $param_names {
        if {[info exists param_default($name)]} {
            lappend param_list [list $name $param_default($name)]
        } else {
            lappend param_list $name
        }
    }


    append source &quot;{$param_list} {\n&quot;
    # We need to reformat the body. If nested inside a namespace eval
    # for example, the body will be indented too much. So we undent the
    # least indented line to 0 spaces and then add 4 spaces for each line.
    append source [::textutil::adjust::indent [::textutil::adjust::undent $body] &quot;    &quot;]
    append source &quot;\n}&quot;
    set doc(source) $source

    return [eval dict create [array get doc]]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatters'>formatters</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Get the list of supported <a href='#::ruff::formatters'>formatters</a>.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>formatters</span> </div></p>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns a list of available <a href='#::ruff::formatters'>formatters</a>.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Get the list of supported <a href='#::ruff::formatters'>formatters</a>.</p>
<p class='ruff'>Ruff! can produce documentation in several formats each of which is produced by a specific formatter. This command returns the list of such <a href='#::ruff::formatters'>formatters</a> that can be used with commands like <a href='#::ruff::document'>document</a>.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_56' href="javascript:toggleSource('56')">Show source</a></p>
<div id='56' class='ruff_dyn_src'><pre>
proc ::ruff::formatters {} {

    # Get the list of supported formatters.
    #
    # Ruff! can produce documentation in several formats each of which
    # is produced by a specific formatter. This command returns the list
    # of such formatters that can be used with commands like
    # document.
    #
    # Returns a list of available formatters.
    variable ruff_dir
    set formatters {}
    set suffix &quot;_formatter.tcl&quot;
    foreach file [glob [file join $ruff_dir *$suffix]] {
        lappend formatters [string range [file tail $file] 0 end-[string length $suffix]]
    }
    return $formatters
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::get_ooclass_method_path'>get_ooclass_method_path</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Calculates the class search order for a method of the specified class</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>get_ooclass_method_path</span> <span class='ruff_arg'>class_name</span> <span class='ruff_arg'>method_name</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>class_name</span></td><td class='ruff_defitem'> name of the class to which the method belongs</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>method_name</span></td><td class='ruff_defitem'> method name being searched for</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns an ordered list containing the classes that are searched to locate a method for the specified class.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Calculates the class search order for a method of the specified class</p>
<p class='ruff'>A method implementation may be provided by the class itself, a mixin or a superclass. This command calculates the order in which these are searched to locate the method. The primary purpose is to find exactly which class actually implements a method exposed by the class.</p>
<p class='ruff'>If a class occurs multiple times due to inheritance or mixins, the LAST occurence of the class is what determines the priority of that class in method selection. Therefore the returned search path may contain repeated elements.</p>
<p class='ruff'>Note that this routine only applies to a class and cannot be used with individual objects which may have their own mix-ins.</p>
<p class='ruff'>Search algorithm:</p>
<ul class='ruff'>
<li>Filters are ignored. They may be invoked but are not considered    implementation of the method itself.</li>
<li>The mixins of a class are searched even before the class itself    as are the superclasses of the mixins.</li>
<li>next in the search path is the class itself</li>
<li>Last in the search order are the superclasses (in recursive fashion)</li>
</ul>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_57' href="javascript:toggleSource('57')">Show source</a></p>
<div id='57' class='ruff_dyn_src'><pre>
proc ::ruff::get_ooclass_method_path {class_name method_name} {

    # Calculates the class search order for a method of the specified class
    # class_name - name of the class to which the method belongs
    # method_name - method name being searched for
    #
    # A method implementation may be provided by the class itself,
    # a mixin or a superclass.
    # This command calculates the order in which these are searched
    # to locate the method. The primary purpose is to find exactly
    # which class actually implements a method exposed by the class.
    #
    # If a class occurs multiple times due to inheritance or
    # mixins, the LAST occurence of the class is what determines
    # the priority of that class in method selection. Therefore
    # the returned search path may contain repeated elements.
    #
    # Note that this routine only applies to a class and cannot be
    # used with individual objects which may have their own mix-ins.


    # TBD - do we need to distinguish private/public methods

    set method_path {}
    #ruff
    # Search algorithm:
    #  - Filters are ignored. They may be invoked but are not considered
    #    implementation of the method itself.
    #  - The mixins of a class are searched even before the class itself
    #    as are the superclasses of the mixins.
    foreach mixin [info class mixins $class_name] {
        # We first need to check if the method name is in the public interface
        # for this class. This step is NOT redundant since a derived
        # class may unexport a method from an inherited class in which
        # case we should not have the inherited classes in the path
        # either.
        if {[lsearch -exact [info class methods $mixin -all] $method_name] &lt; 0} {
            continue
        }

        set method_path [concat $method_path [get_ooclass_method_path $mixin $method_name]]
    }

    #ruff - next in the search path is the class itself
    if {[lsearch -exact [info class methods $class_name] $method_name] &gt;= 0} {
        lappend method_path $class_name
    }

    #ruff - Last in the search order are the superclasses (in recursive fashion)
    foreach super [info class superclasses $class_name] {
        # See comment in mixin code above.
        if {[lsearch -exact [info class methods $super -all] $method_name] &lt; 0} {
            continue
        }
        set method_path [concat $method_path [get_ooclass_method_path $super $method_name]]
    }


    #ruff
    # Returns an ordered list containing the classes that are searched
    # to locate a method for the specified class.
    return $method_path
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::locate_ooclass_method'>locate_ooclass_method</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Locates the classe that implement the specified method of a class</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>locate_ooclass_method</span> <span class='ruff_arg'>class_name</span> <span class='ruff_arg'>method_name</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>class_name</span></td><td class='ruff_defitem'> name of the class to which the method belongs</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>method_name</span></td><td class='ruff_defitem'> method name being searched for</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the name of the implementing class or an empty string if the method is not implemented.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Locates the classe that implement the specified method of a class</p>
<p class='ruff'>The matching class may implement the method itself or through one of its own mix-ins or superclasses.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_58' href="javascript:toggleSource('58')">Show source</a></p>
<div id='58' class='ruff_dyn_src'><pre>
proc ::ruff::locate_ooclass_method {class_name method_name} {

    # Locates the classe that implement the specified method of a class
    # class_name - name of the class to which the method belongs
    # method_name - method name being searched for
    #
    # The matching class may implement the method itself or through
    # one of its own mix-ins or superclasses.
    #
    # Returns the name of the implementing class or an empty string
    # if the method is not implemented.

    # Note: we CANNOT just calculate a canonical search path for a
    # given class and then search along that for a class that
    # implements a method. The search path itself will depend on the
    # specific method being searched for due to the fact that a
    # superclass may not appear in a particular search path if a
    # derived class hides a method (this is just one case, there may
    # be others). Luckily, get_ooclass_method_path does exactly this.


    set class_path [get_ooclass_method_path $class_name $method_name]

    if {[llength $class_path] == 0} {
        return &quot;&quot;;              # Method not found
    }

    # Now we cannot just pick the first element in the path. We have
    # to find the *last* occurence of each class - that will decide
    # the priority order
    set order [dict create]
    set pos 0
    foreach path_elem $class_path {
        dict set order $path_elem $pos
        incr pos
    }

    return [lindex $class_path [lindex [lsort -integer [dict values $order]] 0] 0]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::parse'>parse</a><span class='ns_scope'> [<a href='#::ruff'>::ruff</a>]</span></h4>

<p class='linkline'><a href='#::ruff'>ruff</a>, <a href='#_top'>Top</a></p><p class='ruff'>Creates a <a href='#::ruff::parse'>parse</a> structure given a list of lines that are assumed to be documentation for a programming structure</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>parse</span> <span class='ruff_arg'>lines</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>lines</span></td><td class='ruff_defitem'> a list of lines comprising the documentation</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Creates a <a href='#::ruff::parse'>parse</a> structure given a list of lines that are assumed to be documentation for a programming structure</p>
<p class='ruff'>Empty lines or lines with only whitespace terminate the preceding text block (such as a paragraph or a list).</p>
<p class='ruff'>A bulleted list item starts with a '-' or '*' character. A list item may be continued across multiple lines by indending succeeding lines belonging to the same list item. Note an indented line will terminate the previous list item if it itself looks like a new list item. A bulleted list is returned as a list containing the list items, each of which is a list of lines.</p>
<p class='ruff'>A definition list or parameter list begins with a word followed by whitespace, a '-' character, whitespace and descriptive text. Whether it is treated as a parameter list or a definition list depends on whether it occurs in the comment block. If it occurs at the beginning or just after the summary line, it is treated as a parameter list. In all other cases, it is treated as a definition list. Like a bulleted list, each list item may be continued on succeeding lines by indenting them. Definition and parameter lists are returned as flat list of alternating list item name and list item value pairs. The list item value is itself a list of lines.</p>
<p class='ruff'>An option list is similar to a parameter list except that the first word on the line begins with a '-' character and is possibly followed by more words before the '-' character that separates the descriptive text. The '-' separator must be surrounded by whitespace. The value returned for an option list follows the same structure as for parameter or definition list items. Any line in any documentation block that matches this is always added to the option list, irrespective of where it occurs. This means option descriptions can be mingled with other documentation fragments and will show up in the options section.</p>
<p class='ruff'>Any paragraph that begins with the word 'Returns' is treated as a description of the return value irrespective of where it occurs. It is returned as a list of lines.</p>
<p class='ruff'>Lines beginning with spaces are treated as preformatted text unless they are part of a list item. Preformatted text is returned as a list of lines.</p>
<p class='ruff'>All other text blocks are descriptive text paragraphs. Paragraphs may extend across multiple lines and are terminated either when the line matches one of the list items patterns, an indented line (which is treated as preformatted text), or an empty line. Paragraphs are returned as a list of lines.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_59' href="javascript:toggleSource('59')">Show source</a></p>
<div id='59' class='ruff_dyn_src'><pre>
proc ::ruff::parse {lines} {

    # Creates a parse structure given a list of lines that are assumed
    # to be documentation for a programming structure
    #
    # lines - a list of lines comprising the documentation
    #
    set result(name) &quot;&quot;
    set result(listcollector) {}
    set result(fragment) {}
    set result(state) init
    set result(output) {}
    foreach line $lines {
        switch -regexp -- $line {
            {^\s*$} {
                #ruff
                # Empty lines or lines with only whitespace
                # terminate the preceding
                # text block (such as a paragraph or a list).
                switch -exact -- $result(state) {
                    init -
                    postsummary {
                        # No change
                    }
                    summary {
                        _change_state postsummary result
                    }
                    default {
                        _change_state blank result
                    }
                }
            }
            {^\s*[-\*]\s+(.*)$} {
                #ruff
                # A bulleted list item starts with a '-' or '*' character.
                # A list item may be continued across multiple lines by
                # indending succeeding lines belonging to the same list item.
                # Note an indented line will terminate the previous list
                # item if it itself looks like a new list item.
                # A bulleted
                # list is returned as a list containing the list items, each
                # of which is a list of lines.
                _change_state bulletlist result
                if {![regexp {^\s*[-\*]\s+(.*)$} $line dontcare fragment]} {
                    error &quot;Internal error: regexp did not match after switch statement matched.&quot;
                }
                lappend result(fragment) $fragment
            }
            {^\s*(\w+)\s+-(\s+.*)$} {
                #ruff
                # A definition list or parameter list begins with a word
                # followed by whitespace, a '-' character, whitespace
                # and descriptive
                # text. Whether it is treated as a parameter list or a
                # definition list depends on whether it occurs in the comment
                # block. If it occurs at the beginning or just after the
                # summary line, it is treated as a parameter list.
                # In all other cases, it is treated as a definition list.
                # Like a bulleted list, each list item may be continued
                # on succeeding lines by indenting them.
                # Definition and parameter lists
                # are returned as flat list
                # of alternating list item name and list item value
                # pairs. The list item value is itself a list of lines.
                if {[lsearch -exact {init summary postsummary parameter} $result(state)] &gt;= 0} {
                    _change_state parameter result
                } else {
                    _change_state deflist result
                }
                if {![regexp {^\s*(\w+)\s+-(\s+.*)$} $line dontcare result(name) fragment]} {
                    error &quot;Internal error: regexp did not match after switch statement matched.&quot;
                }
                lappend result(fragment) $fragment
            }
            {^\s*(-\w+.*)\s+-(\s+.*)$} {
                #ruff
                # An option list is similar to a parameter list except that
                # the first word on the line begins with a '-' character and
                # is possibly followed by more words before the '-' character
                # that separates the descriptive text. The '-' separator
                # must be surrounded by whitespace. The value returned
                # for an option list follows the same structure as for
                # parameter or definition list items. Any line in any
                # documentation block that matches this is always added
                # to the option list, irrespective of where it occurs. This
                # means option descriptions can be mingled with other
                # documentation fragments and will show up in the options
                # section.

                _change_state option result

                if {![regexp {^\s*(-\w+.*)\s+-(.*)$} $line dontcare result(name) fragment]} {
                    error &quot;Internal error: regexp did not match after switch statement matched.&quot;
                }
                lappend result(fragment) $fragment
            }
            {^Returns($|\s.*$)} {
                #ruff
                # Any paragraph that begins with the word 'Returns' is treated
                # as a description of the return value irrespective of where
                # it occurs. It is returned as a list of lines.
                _change_state return result
                lappend result(fragment) $line
            }
            {^\s+} {
                #ruff
                # Lines beginning with spaces
                # are treated as preformatted text unless they are part
                # of a list item. Preformatted text is returned as a list
                # of lines.
                switch -exact -- $result(state) {
                    preformatted -
                    bulletlist -
                    deflist -
                    parameter -
                    option {
                        # No change. Keep adding to existing block
                    }
                    default {
                        _change_state preformatted result
                    }
                }
                lappend result(fragment) $line
            }
            default {
                #ruff
                # All other text blocks are descriptive text paragraphs.
                # Paragraphs may extend across multiple lines and are
                # terminated either when the line matches one of the list
                # items patterns, an indented line (which is treated
                # as preformatted text), or an empty line. Paragraphs
                # are returned as a list of lines.

                switch -exact -- $result(state) {
                    init { _change_state summary result }
                    postsummary -
                    blank -
                    bulletlist -
                    parameter -
                    deflist -
                    option -
                    preformatted { _change_state paragraph result }
                    default {
                        # Stay in same state
                    }
                }
                lappend result(fragment) $line
            }
        }
    }
    _change_state finish result; # To process any leftovers in result(fragment)

    # Returns a list of key value pairs where key is one
    # of 'parameter', 'option', 'bulletlist', 'deflist', 'parameter',
    # 'preformatted', 'paragraph' or 'return',
    # and the value
    # is the corresponding value.
    return $result(output)
}
</pre></div>
</div>


<h1 class='ruff'><a name='::ruff::app'>::ruff::app</a></h1>
<h2 class='ruff'><a name='::ruff::app-Commands'>Commands</a></h2>
<h4 class='ruff'><a name='::ruff::app::log_error'>log_error</a><span class='ns_scope'> [<a href='#::ruff::app'>::ruff::app</a>]</span></h4>

<p class='linkline'><a href='#::ruff::app'>app</a>, <a href='#_top'>Top</a></p><p class='ruff'>Stub function to log Ruff! errors.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>log_error</span> <span class='ruff_arg'>msg</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>msg</span></td><td class='ruff_defitem'> the message to be logged</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Stub function to log Ruff! errors.</p>
<p class='ruff'>When Ruff! encounters errors, it calls this command to notify the user. By default, the command writes $msg to stderr output. An application using the ruff package can redefine this command after loading ruff.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_60' href="javascript:toggleSource('60')">Show source</a></p>
<div id='60' class='ruff_dyn_src'><pre>
proc ::ruff::app::log_error {msg} {

    # Stub function to log Ruff! errors.
    # msg - the message to be logged
    #
    # When Ruff! encounters errors, it calls this command to
    # notify the user. By default, the command writes $msg
    # to stderr output. An application using the ruff package
    # can redefine this command after loading ruff.
    puts stderr &quot;$msg&quot;
}
</pre></div>
</div>


<h1 class='ruff'><a name='::ruff::formatter::doctools'>::ruff::formatter::doctools</a></h1>
<h2 class='ruff'><a name='::ruff::formatter::doctools-Commands'>Commands</a></h2>
<h4 class='ruff'><a name='::ruff::formatter::doctools::escape'>escape</a><span class='ns_scope'> [<a href='#::ruff::formatter::doctools'>::ruff::formatter::doctools</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::doctools'>doctools</a>, <a href='#_top'>Top</a></p><p><div class='ruff_synopsis'><span class='ruff_cmd'>escape</span> <span class='ruff_arg'>s</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>s</span></td><td class='ruff_defitem'> string to be escaped</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Protects a string against doctools substitution in text (not to be used inside a doctools command argument as that follows Tcl escaping rules and are easiest escaped by enclosing in braces)</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_61' href="javascript:toggleSource('61')">Show source</a></p>
<div id='61' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::doctools::escape {s} {

    # s - string to be escaped
    # Protects a string against doctools substitution in text
    # (not to be used inside a doctools command argument as that
    # follows Tcl escaping rules and are easiest escaped by enclosing
    # in braces)

    # It appears as though the only characters needing replacing are
    # [ and ]. Other Tcl special chars ($ \ etc.) do not matter
    # return [string map [list \\ \\\\ \[ \[lb\] \] \[rb\] \$ \\\$] $s]
    return [string map [list \[ \[lb\] \] \[rb\]] $s]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::doctools::generate_document'>generate_document</a><span class='ns_scope'> [<a href='#::ruff::formatter::doctools'>::ruff::formatter::doctools</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::doctools'>doctools</a>, <a href='#_top'>Top</a></p><p class='ruff'>Produces documentation in doctools format from the passed in class and proc metainformation.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_document</span> <span class='ruff_arg'>classprocinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classprocinfodict</span></td><td class='ruff_defitem'> dictionary containing meta information about the     classes and procs</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-preamble DICT</span></td><td class='ruff_defitem'> a dictionary indexed by a namespace. Each value is    a flat list of pairs consisting of a heading and    corresponding content. These are inserted into the <a href='#::ruff::document'>document</a>    before the actual class and command descriptions for a namespace.    The key &quot;::&quot; corresponds to documentation to be printed at    the very beginning.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Produces documentation in doctools format from the passed in class and proc metainformation.</p>
<p class='ruff'>In addition to options described in the ruff::document command, the following additional ones may be specified:</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_62' href="javascript:toggleSource('62')">Show source</a></p>
<div id='62' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::doctools::generate_document {classprocinfodict args} {

    # Produces documentation in doctools format from the passed in
    # class and proc metainformation.
    #   classprocinfodict - dictionary containing meta information about the
    #     classes and procs
    #
    # In addition to options described in the ruff::document command,
    # the following additional ones may be specified:
    #   -preamble DICT - a dictionary indexed by a namespace. Each value is
    #    a flat list of pairs consisting of a heading and
    #    corresponding content. These are inserted into the document
    #    before the actual class and command descriptions for a namespace.
    #    The key &quot;::&quot; corresponds to documentation to be printed at
    #    the very beginning.
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.

    array set opts  [list  -includeclasses true  -includeprocs true  -includeprivate false  -includesource false  -hidenamespace &quot;&quot;  -section &quot;n&quot;  -version &quot;0.0&quot;  -name &quot;&quot;  -titledesc &quot;&quot;  -modulename &quot;&quot;  -require {}  -author &quot;&quot;  -keywords {}  -year [clock format [clock seconds] -format %Y]  -preamble [dict create]  ]

    array set opts $args

    # TBD - does anything need to be escape'ed here?
    set doc &quot;\[manpage_begin \&quot;$opts(-name)\&quot; \&quot;$opts(-section)\&quot; \&quot;$opts(-version)\&quot;\]\n&quot;
    if {$opts(-author) ne &quot;&quot;} {
        append doc &quot;\[copyright {$opts(-year) \&quot;$opts(-author)\&quot;}\]\n&quot;
    }
    if {$opts(-titledesc) ne &quot;&quot;} {
        append doc &quot;\[titledesc \&quot;$opts(-titledesc)\&quot;\]\n&quot;
    }
    if {$opts(-modulename) ne &quot;&quot;} {
        append doc &quot;\[moddesc \&quot;$opts(-modulename)\&quot;\]\n&quot;
    }
    if {[llength $opts(-require)]} {
        foreach require $opts(-require) {
            append doc &quot;\[require $require\]\n&quot;
        }
    }

    # Begin the description section
    append doc &quot;\[description\]\n&quot;

    if {[dict exists $opts(-preamble) &quot;::&quot;]} {
        # Print the toplevel (global stuff)
        foreach {sec paras} [dict get $opts(-preamble) &quot;::&quot;] {
            append doc [subsection $sec]
            append doc [_fmtparas $paras]
        }
    }

    set info_by_ns [_sift_classprocinfo $classprocinfodict]

    foreach ns [lsort -dictionary [dict keys $info_by_ns]] {
        append doc [section &quot;Module $ns&quot;]
        if {[dict exists $opts(-preamble) $ns]} {
            foreach {sec paras} [dict get $opts(-preamble) $ns] {
                append doc [section $sec]
                append doc [_fmtparas $paras]
            }
        }

        if {[dict exists $info_by_ns $ns classes]} {
            append doc [section Classes]\n
            append doc [generate_ooclasses [dict get $info_by_ns $ns classes]  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  ]
        }
        if {[dict exists $info_by_ns $ns procs]} {
            append doc [section Commands]\n
            append doc [generate_procs [dict get $info_by_ns $ns procs]  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  ]
        }
    }

    if {[llength $opts(-keywords)] == 0} {
        # dtplite will barf if no keywords in man page. Logged on sf.net
        # as a bug against doctools
        ::ruff::app::log_error &quot;Warning: no keywords specified in this module. If no modules have keywords some versions of the doctools indexer may generate an error in some modes.&quot;
    }

    if {[llength $opts(-keywords)]} {
        append doc [eval keywords $opts(-keywords)]
    }


    append doc &quot;\[manpage_end\]\n&quot;

    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::doctools::generate_ooclass'>generate_ooclass</a><span class='ns_scope'> [<a href='#::ruff::formatter::doctools'>::ruff::formatter::doctools</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::doctools'>doctools</a>, <a href='#_top'>Top</a></p><p class='ruff'>Formats the documentation for a class in doctools format</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_ooclass</span> <span class='ruff_arg'>classinfo</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classinfo</span></td><td class='ruff_defitem'> class information in the format returned   by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the class documentation as a doctools formatted string.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Formats the documentation for a class in doctools format</p>
<p class='ruff'>The following options may be specified:</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_63' href="javascript:toggleSource('63')">Show source</a></p>
<div id='63' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::doctools::generate_ooclass {classinfo args} {


    # Formats the documentation for a class in doctools format
    # classinfo - class information in the format returned
    #   by extract_ooclass
    #
    # The following options may be specified:
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #
    # Returns the class documentation as a doctools formatted string.

    array set opts {-includesource false -hidenamespace &quot;&quot;}
    array set opts $args

    array set aclass $classinfo
    set doc &quot;&quot;

    # The quoting of strings below follows what I understand of doctools
    # - only [ and ] are special in text outside of doctools commands.
    # Such strings are quoted using the escape command. Arguments to
    # doctools commands are quoted using {}.

    set class_name [_trim_namespace $aclass(name) $opts(-hidenamespace)]
    set displayprefix &quot;$class_name.&quot;

    append doc [section &quot;Class $class_name&quot;]

    if {[info exists aclass(constructor)]} {
        append doc [list_begin definitions]
        append doc [generate_proc_or_method $aclass(constructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -displayprefix $displayprefix]
        append doc [list_end]
    }


    if {[llength $aclass(superclasses)]} {
        append doc [subsection &quot;Superclasses&quot;]
        # Don't sort - order matters!
        append doc [escape [join [_trim_namespace_multi $aclass(superclasses) $opts(-hidenamespace)]]]\n
    }
    if {[llength $aclass(subclasses)]} {
        append doc [subsection &quot;Subclasses&quot;]
        # Don't sort - order matters!
        append doc [escape [join [_trim_namespace_multi $aclass(subclasses) $opts(-hidenamespace)]]]\n
    }
    if {[llength $aclass(mixins)]} {
        append doc [subsection &quot;Mixins&quot;]
        # Don't sort - order matters!
        append doc [escape [join [_trim_namespace_multi $aclass(mixins) $opts(-hidenamespace)]]]\n
    }
    if {[llength $aclass(filters)]} {
        append doc [subsection &quot;Filters&quot;]
        # Don't sort - order matters!
        append doc [escape [join $aclass(filters) &quot;, &quot;]]\n
    }
    if {[llength $aclass(external_methods)]} {
        append doc [subsection &quot;External Methods&quot;]
        set external_methods {}
        foreach external_method $aclass(external_methods) {
            # Qualify the name with the name of the implenting class
            foreach {name imp_class} $external_method break
            if {$imp_class ne &quot;&quot;} {
                set name [_trim_namespace $imp_class $opts(-hidenamespace)].$name
            }
            lappend external_methods $name
        }
        append doc [escape [join [lsort $external_methods] &quot;, &quot;]]\n
    }

    append doc [subsection Methods]

    append doc [list_begin definitions]
    if {0} {
        # We are showing constructor as part of class definition
        if {[info exists aclass(constructor)]} {
            append doc [generate_proc_or_method $aclass(constructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -displayprefix $displayprefix]
        }
    }
    if {[info exists aclass(destructor)]} {
        append doc [generate_proc_or_method $aclass(destructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -displayprefix $displayprefix]
    }

    # We want methods and forwarded methods listed together and sorted
    array set methods {}
    foreach methodinfo $aclass(methods) {
        set methods([dict get $methodinfo name]) [list method $methodinfo]
    }
    if {[info exists aclass(forwards)]} {
        foreach forwardinfo $aclass(forwards) {
            set methods([dict get $forwardinfo name]) [list forward $forwardinfo]
        }
    }

    foreach name [lsort [array names methods]] {
        foreach {type info} $methods($name) break
        if {$type eq &quot;method&quot;} {
            append doc [generate_proc_or_method $info  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -displayprefix $displayprefix]
        } else {
            # TBD - check formatting of forwarded methods
            # append doc [call [cmd &quot;${displayprefix}[_trim_namespace [dict get $info name] $opts(-hidenamespace)]&quot;]]
            append doc [call &quot;[arg OBJECT] [cmd $name]&quot;]
            # TBD - link to forwarded method if possible
            append doc &quot;Method forwarded to [cmd [escape [dict get $info forward]]].\n&quot;
        }
    }
    append doc [list_end]

    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::doctools::generate_ooclasses'>generate_ooclasses</a><span class='ns_scope'> [<a href='#::ruff::formatter::doctools'>::ruff::formatter::doctools</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::doctools'>doctools</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a list of class information elements returns as string containing class documentation formatted for doctools</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_ooclasses</span> <span class='ruff_arg'>classinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classinfodict</span></td><td class='ruff_defitem'> dictionary keyed by class name and each element   of which is in the format returned by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a list of class information elements returns as string containing class documentation formatted for doctools</p>
<p class='ruff'>Additional parameters are passed on to the <a href='#::ruff::formatter::doctools::generate_ooclass'>generate_ooclass</a> procedure.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_64' href="javascript:toggleSource('64')">Show source</a></p>
<div id='64' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::doctools::generate_ooclasses {classinfodict args} {

    # Given a list of class information elements returns as string
    # containing class documentation formatted for doctools
    # classinfodict - dictionary keyed by class name and each element
    #   of which is in the format returned by extract_ooclass
    #
    # Additional parameters are passed on to the generate_ooclass procedure.

    set doc &quot;&quot;
    foreach name [lsort [dict keys $classinfodict]] {
        append doc  [eval [list generate_ooclass [dict get $classinfodict $name]] $args]
        append doc &quot;\n\n&quot;
    }
    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::doctools::generate_proc_or_method'>generate_proc_or_method</a><span class='ns_scope'> [<a href='#::ruff::formatter::doctools'>::ruff::formatter::doctools</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::doctools'>doctools</a>, <a href='#_top'>Top</a></p><p class='ruff'>Formats the documentation for a proc in doctools format</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_proc_or_method</span> <span class='ruff_arg'>procinfo</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procinfo</span></td><td class='ruff_defitem'> class information in the format returned   by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-displayprefix METHODNAME</span></td><td class='ruff_defitem'> the string to use as a prefix     for the method or proc name. Usually caller supplies this     as the class name for the method.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the proc documentation as a doctools formatted string.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Formats the documentation for a proc in doctools format</p>
<p class='ruff'>The following options may be specified:</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_65' href="javascript:toggleSource('65')">Show source</a></p>
<div id='65' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::doctools::generate_proc_or_method {procinfo args} {

    # Formats the documentation for a proc in doctools format
    # procinfo - class information in the format returned
    #   by extract_ooclass
    #
    # The following options may be specified:
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -displayprefix METHODNAME - the string to use as a prefix
    #     for the method or proc name. Usually caller supplies this
    #     as the class name for the method.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #
    # Returns the proc documentation as a doctools formatted string.


    array set opts {-includesource false -displayprefix &quot;&quot; -hidenamespace &quot;&quot;}
    array set opts $args

    array set aproc $procinfo

    set doc &quot;&quot;

    # The quoting of strings below follows what I understand of doctools
    # - only [ and ] are special in text outside of doctools commands.
    # Such strings are quoted using the escape command. Arguments to
    # doctools commands are quoted using {}.

    set itemlist {};            # For the parameter descriptions
    set arglist {};             # For the synopsis
    # Construct command synopsis
    foreach param $aproc(parameters) {
        if {[dict get $param type] ne &quot;parameter&quot;} {
            # We do not deal with options here
            continue
        }
        set name [dict get $param name]
        set item [arg_def {} $name]
        if {[dict exists $param description]} {
            append item &quot; [escape [dict get $param description]]&quot;
        }
        if {[dict exists $param default]} {
            lappend arglist [opt [arg $name]]
            append item &quot; (default \[const {[dict get $param default]}\])&quot;
        } else {
            lappend arglist [arg $name]
        }
        lappend itemlist $item
    }
    set proc_name $opts(-displayprefix)[_trim_namespace $aproc(name) $opts(-hidenamespace)]

    if {$aproc(proctype) ne &quot;method&quot;} {
        append doc [eval [list call [cmd $proc_name]] $arglist]\n
    } else {
        switch -exact -- $aproc(name) {
            constructor {append doc [eval [list call [cmd &quot;::oo::class create [_trim_namespace $aproc(class) $opts(-hidenamespace)]&quot;]] $arglist]}
            destructor  {append doc [call &quot;[arg OBJECT] [cmd destroy]&quot;]}
            default  {append doc [eval [list call &quot;[arg OBJECT] [cmd $aproc(name)]&quot;] $arglist]}
        }
    }

    set sep &quot;&quot;
    # Parameter description
    if {[llength $itemlist]} {
        append doc [list_begin arguments]\n
        append doc [join $itemlist \n]\n
        append doc [list_end]\n
        set sep [para]
    }

    # Option description
    set itemlist {}
    foreach param $aproc(parameters) {
        if {[dict get $param type] ne &quot;option&quot;} {
            continue
        }
        set name [dict get $param name]
        if {[llength $name] &gt; 1} {
            set arg  [arg [lrange $name 1 end]]
            set name [option [lindex $name 0]]
        } else {
            set name [option $name]
            set arg {}
        }
        if {[dict exists $param description]} {
            set desc [dict get $param description]
        } else {
            set desc &quot;No description available.&quot;
        }
        lappend itemlist [opt_def $name $arg] [escape $desc]
    }
    if {[llength $itemlist]} {
        append doc $sep
        append doc [list_begin options]
        append doc [join $itemlist \n]\n
        append doc [list_end]\n
        set sep [para]
    }

    # Loop through all the paragraphs
    set paras [_fmtparas $aproc(description)]
    if {$paras ne &quot;&quot;} {
        append doc $sep$paras
        set sep [para]
    }

    if {[info exists aproc(return)] &amp;&amp; $aproc(return) ne &quot;&quot;} {
        append doc $sep
        append doc [escape $aproc(return)]
    }

    if {$opts(-includesource)} {
        append doc $sep
        append doc &quot;Source:&quot;
        append doc [para]

        # Just [escape...] won't do it. We need the example_begin as well
        append doc &quot;\[example_begin\]\n&quot;
        append doc [escape $aproc(source)]
        append doc &quot;\[example_end\]\n&quot;
    }


    return &quot;${doc}\n&quot;
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::doctools::generate_procs'>generate_procs</a><span class='ns_scope'> [<a href='#::ruff::formatter::doctools'>::ruff::formatter::doctools</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::doctools'>doctools</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a dictionary of proc information elements returns a string containing documentation formatted for doctools</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_procs</span> <span class='ruff_arg'>procinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procinfodict</span></td><td class='ruff_defitem'> dictionary keyed by name of the proc with the associated   value being in the format returned by <a href='#::ruff::extract_proc'>extract_proc</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a dictionary of proc information elements returns a string containing documentation formatted for doctools</p>
<p class='ruff'>Additional parameters are passed on to the generate_proc procedure.</p>
<p class='ruff'>The returned procedure descriptions are sorted in alphabetical order.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_66' href="javascript:toggleSource('66')">Show source</a></p>
<div id='66' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::doctools::generate_procs {procinfodict args} {

    # Given a dictionary of proc information elements returns a string
    # containing documentation formatted for doctools
    # procinfodict - dictionary keyed by name of the proc with the associated
    #   value being in the format returned by extract_proc
    #
    # Additional parameters are passed on to the generate_proc procedure.

    #ruff
    # The returned procedure descriptions are sorted in alphabetical order.
    set doc &quot;\[list_begin definitions\]\n&quot;
    foreach name [lsort -dictionary [dict keys $procinfodict]] {
        append doc  [eval [list generate_proc_or_method [dict get $procinfodict $name]] $args]\n\n
    }
    append doc &quot;\[list_end\]\n&quot;

    return $doc
}
</pre></div>
</div>


<h1 class='ruff'><a name='::ruff::formatter::html'>::ruff::formatter::html</a></h1>
<h2 class='ruff'><a name='::ruff::formatter::html-Commands'>Commands</a></h2>
<h4 class='ruff'><a name='::ruff::formatter::html::escape'>escape</a><span class='ns_scope'> [<a href='#::ruff::formatter::html'>::ruff::formatter::html</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::html'>html</a>, <a href='#_top'>Top</a></p><p class='ruff'>Returns the escaped string</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>escape</span> <span class='ruff_arg'>s</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>s</span></td><td class='ruff_defitem'> string to be escaped</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the escaped string</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Protects characters in $s against interpretation as HTML special characters.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_67' href="javascript:toggleSource('67')">Show source</a></p>
<div id='67' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::html::escape {s} {

    # s - string to be escaped
    # Protects characters in $s against interpretation as
    # HTML special characters.
    #
    # Returns the escaped string

    return [string map {
        &amp;    &amp;amp;
        \&quot;   &amp;quot;
        &lt;    &amp;lt;
        &gt;    &amp;gt;
    } $s]
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::html::generate_document'>generate_document</a><span class='ns_scope'> [<a href='#::ruff::formatter::html'>::ruff::formatter::html</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::html'>html</a>, <a href='#_top'>Top</a></p><p class='ruff'>Produces documentation in HTML format from the passed in class and proc metainformation.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_document</span> <span class='ruff_arg'>classprocinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classprocinfodict</span></td><td class='ruff_defitem'> dictionary containing meta information about the    classes and procs</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-preamble DICT</span></td><td class='ruff_defitem'> a dictionary indexed by a namespace. Each value is    a flat list of pairs consisting of a heading and    corresponding content. These are inserted into the <a href='#::ruff::document'>document</a>    before the actual class and command descriptions for a namespace.    The key &quot;::&quot; corresponds to documentation to be printed at    the very beginning.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-stylesheet URLLIST</span></td><td class='ruff_defitem'> if specified, the stylesheets passed in URLLIST    are used instead of the built-in styles. Note the built-in YUI is always    included.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-titledesc STRING</span></td><td class='ruff_defitem'> the title for the documentation.    Used as the title for the <a href='#::ruff::document'>document</a>.    If undefined, the string &quot;Reference&quot; is used.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Produces documentation in HTML format from the passed in class and proc metainformation.</p>
<p class='ruff'>The following options may be specified:</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_68' href="javascript:toggleSource('68')">Show source</a></p>
<div id='68' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::html::generate_document {classprocinfodict args} {

    # Produces documentation in HTML format from the passed in
    # class and proc metainformation.
    #   classprocinfodict - dictionary containing meta information about the
    #    classes and procs
    # The following options may be specified:
    #   -preamble DICT - a dictionary indexed by a namespace. Each value is
    #    a flat list of pairs consisting of a heading and
    #    corresponding content. These are inserted into the document
    #    before the actual class and command descriptions for a namespace.
    #    The key &quot;::&quot; corresponds to documentation to be printed at
    #    the very beginning.
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #   -titledesc STRING - the title for the documentation.
    #    Used as the title for the document.
    #    If undefined, the string &quot;Reference&quot; is used.
    #   -stylesheet URLLIST - if specified, the stylesheets passed in URLLIST
    #    are used instead of the built-in styles. Note the built-in YUI is always
    #    included.

    variable yui_style;         # Contains default YUI based layout
    variable ruff_style;        # Contains default Ruff style sheet
    variable javascript;        # Javascript used by the page
    variable navlinks;          # Links generated for navigation menu
    variable link_targets;    # Links for cross-reference purposes

    # Re-initialize in case of multiple invocations
    array unset link_targets
    array set link_targets {}
    set navlinks [dict create]

    array set opts  [list  -includesource false  -hidenamespace &quot;&quot;  -titledesc &quot;&quot;  -modulename &quot;Reference&quot;  ]

    array set opts $args

    # TBD - create a link_target entry for each namespace

    # First collect all &quot;important&quot; names so as to build a list of
    # linkable targets. These will be used for cross-referencing and
    # also to generate links correctly in the case of
    # duplicate names in different namespaces or classes.
    #
    # A class name is also treated as a namespace component
    # although that is not strictly true.
    # TBD - the linked_targets and navlinks should really be merged
    # in some fashion as they overlap in function. The difference is
    # that the former needs to be built before any text processing is
    # done so linking in paras can be done. The latter is created as
    # the text is processed and also contains only links to be displayed
    # in the navigation menu.
    foreach {class_name class_info} [dict get $classprocinfodict classes] {
        set ns [namespace qualifiers $class_name]
        set link_targets($class_name) [_anchor $class_name]
        set method_info_list [concat [dict get $class_info methods] [dict get $class_info forwards]]
        foreach name {constructor destructor} {
            if {[dict exists $class_info $name]} {
                lappend method_info_list [dict get $class_info $name]
            }
        }
        foreach method_info $method_info_list {
            # The class name is the scope for methods. Because of how
            # the link target lookup works, we use the namespace
            # operator to separate the class from method. We also
            # store it a second time using the &quot;.&quot; separator as that
            # is how they are sometimes referenced.
            set method_name [dict get $method_info name]
            set anchor [_anchor ${class_name}::${method_name}]
            set link_targets(${class_name}::${method_name}) $anchor
            set link_targets(${class_name}.${method_name}) $anchor
        }
    }
    foreach proc_name [dict keys [dict get $classprocinfodict procs]] {
        set link_targets(${proc_name}) [_anchor $proc_name]
    }

    set doc {&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;&gt;}
    append doc &quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;$opts(-titledesc)&lt;/title&gt;\n&quot;
    if {[info exists opts(-stylesheets)]} {
        append doc &quot;&lt;style&gt;\n$yui_style\n&lt;/style&gt;\n&quot;
        foreach url $opts(-stylesheets) {
            append doc &quot;&lt;link rel='stylesheet' type='text/css' href='$url' /&gt;&quot;
        }
    } else {
        # Use built-in styles
        append doc &quot;&lt;style&gt;\n$yui_style\n$ruff_style\n&lt;/style&gt;\n&quot;
    }
    append doc &quot;&lt;script&gt;$javascript&lt;/script&gt;&quot;
    append doc &quot;&lt;/head&gt;&lt;body&gt;&quot;

    # YUI stylesheet templates
    append doc &quot;&lt;div id='doc3' class='yui-t2'&gt;&quot;
    if {$opts(-titledesc) ne &quot;&quot;} {
        append doc &quot;&lt;div id='hd' class='banner'&gt;\n$opts(-titledesc)\n&lt;/div&gt;\n&quot;
    }
    append doc &quot;&lt;div id='bd'&gt;&quot;
    append doc &quot;&lt;div id='yui-main'&gt;&quot;
    append doc &quot;&lt;div class='yui-b'&gt;&quot;
    append doc &quot;&lt;a name='_top'&gt;&lt;/a&gt;&quot;

    # Build a regexp that can be used to convert references to classes, methods
    # and procedures to links.
    set methods {}
    foreach {class_name class_info} [dict get $classprocinfodict classes] {
        # Note we add both forms of method qualification - using :: and . -
        # since comments might be use both forms.
        foreach name {constructor destructor} {
            if {[dict exists $class_info $name]} {
                lappend methods ${class_name}.$name ${class_name}::$name
            }
        }
        foreach method_info [dict get $class_info methods] {
            lappend methods ${class_name}.[dict get $method_info name] ${class_name}::[dict get $method_info name]
        }
        foreach method_info [dict get $class_info forwards] {
            lappend methods ${class_name}.[dict get $method_info name] ${class_name}::[dict get $method_info name]
        }
    }
    set ref_regexp [_build_symbol_regexp  [concat  [dict keys [dict get $classprocinfodict procs]]  [dict keys [dict get $classprocinfodict classes]]  $methods
                            ]
                   ]

    if {$opts(-modulename) ne &quot;&quot;} {
        append doc [_fmthead $opts(-modulename) 1]
    }

    if {[info exists opts(-preamble)] &amp;&amp;
        [dict exists $opts(-preamble) &quot;::&quot;]} {
        # Print the toplevel (global stuff)
        foreach {sec paras} [dict get $opts(-preamble) &quot;::&quot;] {
            append doc [_fmthead $sec 1]
            append doc [_fmtparas $paras $ref_regexp]
        }
    }

    set info_by_ns [_sift_classprocinfo $classprocinfodict]
    foreach ns [lsort [dict keys $info_by_ns]] {
        set link_targets($ns) [_anchor $ns]
        append doc [_fmthead $ns 1]

        if {[info exists opts(-preamble)] &amp;&amp;
            [dict exists $opts(-preamble) $ns]} {
            # Print the preamble for this namespace
            foreach {sec paras} [dict get $opts(-preamble) $ns] {
                append doc [_fmthead $sec 2]
                append doc [_fmtparas $paras $ref_regexp]
            }
        }

        if {[dict exists $info_by_ns $ns procs]} {
            append doc [_fmthead &quot;Commands&quot; 2 -namespace $ns]
            append doc [generate_procs [dict get $info_by_ns $ns procs]  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $ref_regexp  ]
        }

        if {[dict exists $info_by_ns $ns classes]} {
            append doc [_fmthead &quot;Classes&quot; 2 -namespace $ns]
            append doc [generate_ooclasses [dict get $info_by_ns $ns classes]  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $ref_regexp  ]
        }
    }
    append doc &quot;&lt;/div&gt;&quot;;        # &lt;div class='yui-b'&gt;
    append doc &quot;&lt;/div&gt;&quot;;        # &lt;div id='yui-main'&gt;

    # Add the navigation bits
    append doc &quot;&lt;div class='yui-b navbox'&gt;&quot;
    dict for {text link} $navlinks {
        set label [dict get $link label]
        set tag  [dict get $link tag]
        set href [dict get $link href]
        if {[dict exists $link tip]} {
            append doc &quot;&lt;$tag&gt;&lt;a class='tooltip' href='$href'&gt;$label&lt;span&gt;[dict get $link tip]&lt;/span&gt;&lt;/a&gt;&lt;/$tag&gt;&quot;
        } else {
            append doc &quot;&lt;$tag&gt;&lt;a href='$href'&gt;$label&lt;/a&gt;&lt;/$tag&gt;&quot;
        }
    }
    append doc &quot;&lt;/div&gt;&quot;;        # &lt;div class='yui-b' for navigation&gt;

    append doc &quot;&lt;/div&gt;&quot;;        # &lt;div id='bd'&gt;

    # The footer
    append doc &quot;&lt;div id='ft'&gt;&quot;
    append doc &quot;&lt;div style='float: right;'&gt;Document generated by Ruff!&lt;/div&gt;&quot;
    if {[info exists opts(-copyright)]} {
        append doc &quot;&lt;div&gt;&amp;copy; [escape $opts(-copyright)]&lt;/div&gt;&quot;
    }
    append doc &quot;&lt;/div&gt;\n&quot;

    append doc &quot;&lt;/div&gt;&quot;;        # &lt;div id='doc3' class='t3'&gt;
    append doc &quot;&lt;/body&gt;&lt;/html&gt;&quot;

    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::html::generate_ooclass'>generate_ooclass</a><span class='ns_scope'> [<a href='#::ruff::formatter::html'>::ruff::formatter::html</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::html'>html</a>, <a href='#_top'>Top</a></p><p class='ruff'>Formats the documentation for a class in HTML format</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_ooclass</span> <span class='ruff_arg'>classinfo</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classinfo</span></td><td class='ruff_defitem'> class information in the format returned   by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,  program element names beginning with NAMESPACE are shown  with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the   procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-linkregexp REGEXP</span></td><td class='ruff_defitem'> if specified, any word matching the  regular expression REGEXP is marked as a link.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the class documentation as a NaturalDocs formatted string.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Formats the documentation for a class in HTML format</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_69' href="javascript:toggleSource('69')">Show source</a></p>
<div id='69' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::html::generate_ooclass {classinfo args} {


    # Formats the documentation for a class in HTML format
    # classinfo - class information in the format returned
    #   by extract_ooclass
    # -includesource BOOLEAN - if true, the source code of the
    #   procedure is also included. Default value is false.
    # -hidenamespace NAMESPACE - if specified as non-empty,
    #  program element names beginning with NAMESPACE are shown
    #  with that namespace component removed.
    # -linkregexp REGEXP - if specified, any word matching the
    #  regular expression REGEXP is marked as a link.
    #
    # Returns the class documentation as a NaturalDocs formatted string.

    variable header_levels
    array set opts {
        -includesource false
        -hidenamespace &quot;&quot;
        -mergeconstructor false
        -linkregexp &quot;&quot;
    }
    array set opts $args

    array set aclass $classinfo
    set class_name [_trim_namespace $aclass(name) $opts(-hidenamespace)]
    set scope [namespace qualifiers $aclass(name)]

    array set method_summaries {}

    # We want to put the class summary right after the header but cannot
    # generate it till the end so we put the header in a separate variable
    # to be merged at the end.
    append dochdr [_fmtprochead $aclass(name) -level $header_levels(class)]

    set doc &quot;&quot;
    # Include constructor in main class definition
    if {$opts(-mergeconstructor) &amp;&amp; [info exists aclass(constructor)]} {
        error &quot;-mergeconstructor not implemented&quot;
        TBD
        append doc [generate_proc_or_method $aclass(constructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -skipsections [list header name]  -linkregexp $opts(-linkregexp)  ]
    }

    if {[llength $aclass(superclasses)]} {
        append doc [_fmthead Superclasses $header_levels(nonav)]
        # Don't sort - order matters!
        append doc [_fmtpara [join [_trim_namespace_multi $aclass(superclasses) $opts(-hidenamespace)] {, }] $opts(-linkregexp) $scope]
    }
    if {[llength $aclass(mixins)]} {
        append doc [_fmthead &quot;Mixins&quot; $header_levels(nonav)]

        # Don't sort - order matters!
        append doc [_fmtpara [join [_trim_namespace_multi $aclass(mixins) $opts(-hidenamespace)] {, }] $opts(-linkregexp) $scope]
    }

    if {[llength $aclass(subclasses)]} {
        # Don't sort - order matters!
        append doc [_fmthead &quot;Subclasses&quot; $header_levels(nonav)]
        append doc [_fmtpara [join [_trim_namespace_multi $aclass(subclasses) $opts(-hidenamespace)] {, }] $opts(-linkregexp) $scope]
    }

    # Inherited and derived methods are listed as such.
    if {[llength $aclass(external_methods)]} {
        array set external_methods {}
        foreach external_method $aclass(external_methods) {
            # Qualify the name with the name of the implenting class
            foreach {name imp_class} $external_method break
            if {$imp_class ne &quot;&quot;} {
                set imp_class [_trim_namespace_multi $imp_class $opts(-hidenamespace)]
            }
            lappend external_methods($imp_class) ${imp_class}.$name
            set method_summaries($name) [dict create label [escape $name] desc [_linkify &quot;See ${imp_class}.$name&quot; $opts(-linkregexp) $scope]]
        }
        append doc [_fmthead &quot;Inherited and mixed-in methods&quot; $header_levels(nonav)]
        # Construct a sorted list based on inherit/mixin class name
        set ext_list {}
        foreach imp_class [lsort -dictionary [array names external_methods]] {
            lappend ext_list  [_linkify $imp_class $opts(-linkregexp) $scope]  [_linkify $external_methods($imp_class)  $opts(-linkregexp)  $imp_class]
        }
        append doc [_fmtdeflist $ext_list -preformatted both]
    }
    if {[llength $aclass(filters)]} {
        append doc [_fmthead &quot;Filters&quot; $header_levels(nonav)]
        append doc [_fmtpara [join [lsort $aclass(filters)] {, }] $opts(-linkregexp) $scope]
    }

    if {[info exists aclass(constructor)] &amp;&amp; !$opts(-mergeconstructor)} {
        set method_summaries($aclass(name).constructor) [dict create label [_linkify &quot;$aclass(name).constructor&quot; $opts(-linkregexp) $aclass(name)] desc &quot;Constructor for the class&quot; ]
        append doc [generate_proc_or_method $aclass(constructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $opts(-linkregexp)  ]
    }
    if {[info exists aclass(destructor)]} {
        set method_summaries($aclass(name).destructor) [dict create label [_linkify &quot;$aclass(name).destructor&quot; $opts(-linkregexp) $aclass(name)] desc &quot;Destructor for the class&quot; ]
        append doc [generate_proc_or_method $aclass(destructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $opts(-linkregexp)  ]
    }

    # We want methods and forwarded methods listed together and sorted
    array set methods {}
    foreach methodinfo $aclass(methods) {
        set methods([dict get $methodinfo name]) [list method $methodinfo]
    }
    if {[info exists aclass(forwards)]} {
        foreach forwardinfo $aclass(forwards) {
            set methods([dict get $forwardinfo name]) [list forward $forwardinfo]
        }
    }

    foreach name [lsort [array names methods]] {
        foreach {type info} $methods($name) break
        if {$type eq &quot;method&quot;} {
            append doc [generate_proc_or_method $info  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $opts(-linkregexp)  ]
            if {[dict exists $info summary]} {
                set summary [escape [dict get $info summary]]
            } elseif {[dict exists $info return]} {
                set summary [escape [dict get $info return]]
            } else {
                set summary &quot;&quot;
            }
            set method_summaries($aclass(name).$name) [dict create label [_linkify $aclass(name).$name $opts(-linkregexp) $aclass(name)] desc $summary]
        } else {
            set forward_text &quot;Method forwarded to [dict get $info forward]&quot;
            append doc [_fmtprochead $aclass(name)::$name -tooltip $forward_text -level $header_levels(method)]
            append doc [_fmtpara $forward_text $opts(-linkregexp) $scope]
            set method_summaries($aclass(name).$name) [dict create label [_linkify $aclass(name).$name  $opts(-linkregexp) $aclass(name)] desc [_linkify $forward_text $opts(-linkregexp) $scope]]
        }
    }

    set summary_list {}
    foreach name [lsort -dictionary [array names method_summaries]] {
        lappend summary_list [dict get $method_summaries($name) label] [dict get $method_summaries($name) desc]
    }
    if {[llength $summary_list]} {
        # append dochdr [_fmthead &quot;Method summary&quot; $header_levels(nonav)]
        append dochdr [_fmtdeflist $summary_list -preformatted both]
    }

    return &quot;$dochdr\n$doc&quot;
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::html::generate_ooclasses'>generate_ooclasses</a><span class='ns_scope'> [<a href='#::ruff::formatter::html'>::ruff::formatter::html</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::html'>html</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a list of class information elements returns as string containing class documentation formatted for NaturalDocs</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_ooclasses</span> <span class='ruff_arg'>classinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classinfodict</span></td><td class='ruff_defitem'> dictionary keyed by class name and each element   of which is in the format returned by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a list of class information elements returns as string containing class documentation formatted for NaturalDocs</p>
<p class='ruff'>Additional parameters are passed on to the <a href='#::ruff::formatter::html::generate_ooclass'>generate_ooclass</a> procedure.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_70' href="javascript:toggleSource('70')">Show source</a></p>
<div id='70' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::html::generate_ooclasses {classinfodict args} {

    # Given a list of class information elements returns as string
    # containing class documentation formatted for NaturalDocs
    # classinfodict - dictionary keyed by class name and each element
    #   of which is in the format returned by extract_ooclass
    #
    # Additional parameters are passed on to the generate_ooclass procedure.

    set doc &quot;&quot;
    foreach name [lsort [dict keys $classinfodict]] {
        append doc  [eval [list generate_ooclass [dict get $classinfodict $name]] $args]
        append doc &quot;\n\n&quot;
    }

    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::html::generate_proc_or_method'>generate_proc_or_method</a><span class='ns_scope'> [<a href='#::ruff::formatter::html'>::ruff::formatter::html</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::html'>html</a>, <a href='#_top'>Top</a></p><p class='ruff'>Formats the documentation for a proc in HTML format</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_proc_or_method</span> <span class='ruff_arg'>procinfo</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procinfo</span></td><td class='ruff_defitem'> proc or method information in the format returned   by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-linkregexp REGEXP</span></td><td class='ruff_defitem'> if specified, any word matching the    regular expression REGEXP is marked as a link.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-skipsections SECTIONLIST</span></td><td class='ruff_defitem'> a list of sections to be left    out from the generated <a href='#::ruff::document'>document</a>. This is generally useful    if the return value is to be included as part of a larger    section (e.g. constructor within a class)</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the proc documentation as a HTML formatted string.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Formats the documentation for a proc in HTML format</p>
<p class='ruff'>The following options may be specified:</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_71' href="javascript:toggleSource('71')">Show source</a></p>
<div id='71' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::html::generate_proc_or_method {procinfo args} {

    # Formats the documentation for a proc in HTML format
    # procinfo - proc or method information in the format returned
    #   by extract_ooclass
    #
    # The following options may be specified:
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #   -skipsections SECTIONLIST - a list of sections to be left
    #    out from the generated document. This is generally useful
    #    if the return value is to be included as part of a larger
    #    section (e.g. constructor within a class)
    #   -linkregexp REGEXP - if specified, any word matching the
    #    regular expression REGEXP is marked as a link.
    #
    # Returns the proc documentation as a HTML formatted string.

    variable header_levels

    array set opts {
        -includesource false
        -hidenamespace &quot;&quot;
        -skipsections {}
        -linkregexp &quot;&quot;
    }
    array set opts $args

    array set aproc $procinfo

    if {$aproc(proctype) ne &quot;method&quot;} {
        set scope [namespace qualifiers $aproc(name)]
    } else {
        set scope $aproc(class); # Scope is name of class
    }

    set doc &quot;&quot;;                 # Document string

    set header_title [_trim_namespace $aproc(name) $opts(-hidenamespace)]
    set proc_name [_trim_namespace $aproc(name) $opts(-hidenamespace)]

    # Construct the synopsis and simultaneously the parameter descriptions
    # These are constructed as HTML (ie. already escaped) since we want
    # to format parameters etc.
    set desclist {};            # For the parameter descriptions
    set arglist {};             # Used later for synopsis
    foreach param $aproc(parameters) {
        set name [dict get $param name]
        set desc {}
        if {[dict get $param type] eq &quot;parameter&quot;} {
            lappend arglist [_arg $name]
            if {[dict exists $param default]} {
                lappend desc &quot;(optional, default [_const [dict get $param default]])&quot;
            }
        }
        if {[dict exists $param description]} {
            lappend desc [_linkify [dict get $param description] $opts(-linkregexp) $scope]
        } elseif {$name eq &quot;args&quot;} {
            lappend desc &quot;Additional options.&quot;
        }

        lappend desclist [_arg $name] [join $desc &quot; &quot;]
    }

    if {$aproc(proctype) ne &quot;method&quot;} {
        set synopsis &quot;[_cmd [namespace tail $proc_name]] [join $arglist { }]&quot;
    } else {
        switch -exact -- $aproc(name) {
            constructor {set synopsis &quot;[_cmd $aproc(class)] [_cmd create] [join $arglist { }]&quot;}
            destructor  {set synopsis &quot;[_arg OBJECT] [_cmd destroy]&quot;}
            default  {set synopsis &quot;[_arg OBJECT] [_cmd [namespace tail $aproc(name)]] [join $arglist { }]&quot;}
        }
    }

    if {[info exists aproc(summary)] &amp;&amp; $aproc(summary) ne &quot;&quot;} {
        set summary $aproc(summary)
    } elseif {[info exists aproc(return)] &amp;&amp; $aproc(return) ne &quot;&quot;} {
        set summary $aproc(return)
    }

    if {[lsearch -exact $opts(-skipsections) header] &lt; 0} {
        # We need a fully qualified name for cross-linking purposes
        if {$aproc(proctype) eq &quot;method&quot;} {
            set fqn $aproc(class)::$aproc(name)
        } else {
            set fqn $aproc(name)
        }

        if {[info exists summary]} {
            append doc [_fmtprochead $fqn -tooltip $summary -level $header_levels($aproc(proctype))]
        } else {
            append doc [_fmtprochead $fqn -level $header_levels($aproc(proctype))]
        }
    }

    if {[info exists summary]} {
        append doc [_fmtpara $summary $opts(-linkregexp) $scope]
    }

    append doc &quot;&lt;p&gt;&lt;div class='ruff_synopsis'&gt;$synopsis&lt;/div&gt;&lt;/p&gt;\n&quot;

    if {[llength $desclist]} {
        append doc [_fmthead Parameters $header_levels(nonav)]
        # Parameters are output as a list.
        append doc [_fmtdeflist $desclist -preformatted both]
    }

    if {[info exists aproc(return)] &amp;&amp; $aproc(return) ne &quot;&quot;} {
        append doc [_fmthead &quot;Return value&quot; $header_levels(nonav)]
        append doc [_fmtpara $aproc(return) $opts(-linkregexp) $scope]
    }

    # Loop through all the paragraphs. Note the first para is also
    # the summary (already output) but we will show that in the general
    # description as well.
    if {[llength $aproc(description)]} {
        append doc [_fmthead &quot;Description&quot; $header_levels(nonav)]
        append doc [_fmtparas $aproc(description) $opts(-linkregexp) $scope]
    }

    # Do we include the source code in the documentation?
    if {$opts(-includesource)} {
        set src_id [_new_srcid]
        append doc &quot;&lt;div class='ruff_source'&gt;&quot;
        append doc &quot;&lt;p class='ruff_source_link'&gt;&quot;
        append doc &quot;&lt;a id='l_$src_id' href=\&quot;javascript:toggleSource('$src_id')\&quot;&gt;Show source&lt;/a&gt;&quot;
        append doc &quot;&lt;/p&gt;\n&quot;
        append doc &quot;&lt;div id='$src_id' class='ruff_dyn_src'&gt;&lt;pre&gt;\n[escape $aproc(source)]\n&lt;/pre&gt;&lt;/div&gt;\n&quot;
        append doc &quot;&lt;/div&gt;&quot;;    # class='ruff_source'
    }


    return &quot;${doc}\n&quot;
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::html::generate_procs'>generate_procs</a><span class='ns_scope'> [<a href='#::ruff::formatter::html'>::ruff::formatter::html</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::html'>html</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a dictionary of proc information elements returns a string containing HTML format documentation.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_procs</span> <span class='ruff_arg'>procinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procinfodict</span></td><td class='ruff_defitem'> dictionary keyed by name of the proc with the associated   value being in the format returned by <a href='#::ruff::extract_proc'>extract_proc</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns documentation string in NaturalDocs format with procedure descriptions sorted in alphabetical order within each namespace.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a dictionary of proc information elements returns a string containing HTML format documentation.</p>
<p class='ruff'>Additional parameters are passed on to the generate_proc procedure.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_72' href="javascript:toggleSource('72')">Show source</a></p>
<div id='72' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::html::generate_procs {procinfodict args} {

    # Given a dictionary of proc information elements returns a string
    # containing HTML format documentation.
    # procinfodict - dictionary keyed by name of the proc with the associated
    #   value being in the format returned by extract_proc
    #
    # Additional parameters are passed on to the generate_proc procedure.
    #
    # Returns documentation string in NaturalDocs format with
    # procedure descriptions sorted in alphabetical order
    # within each namespace.

    set doc &quot;&quot;
    set namespaces [_sift_names [dict keys $procinfodict]]
    foreach ns [lsort -dictionary [dict keys $namespaces]] {
        foreach name [lsort -dictionary [dict get $namespaces $ns]] {
            append doc  [eval [list generate_proc_or_method [dict get $procinfodict $name]] $args]\n\n
        }
    }

    return $doc
}
</pre></div>
</div>


<h1 class='ruff'><a name='::ruff::formatter::naturaldocs'>::ruff::formatter::naturaldocs</a></h1>
<h2 class='ruff'><a name='::ruff::formatter::naturaldocs-Commands'>Commands</a></h2>
<h4 class='ruff'><a name='::ruff::formatter::naturaldocs::generate_document'>generate_document</a><span class='ns_scope'> [<a href='#::ruff::formatter::naturaldocs'>::ruff::formatter::naturaldocs</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::naturaldocs'>naturaldocs</a>, <a href='#_top'>Top</a></p><p class='ruff'>Produces documentation in NaturalDocs format from the passed in class and proc metainformation.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_document</span> <span class='ruff_arg'>classprocinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classprocinfodict</span></td><td class='ruff_defitem'> dictionary containing meta information about the    classes and procs</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-modulename NAME</span></td><td class='ruff_defitem'> the name of the module. Used as the title for the <a href='#::ruff::document'>document</a>.    If undefined, the string &quot;Reference&quot; is used.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-preamble DICT</span></td><td class='ruff_defitem'> a dictionary indexed by a namespace. Each value is    a flat list of pairs consisting of a heading and    corresponding content. These are inserted into the <a href='#::ruff::document'>document</a>    before the actual class and command descriptions for a namespace.    The key &quot;::&quot; corresponds to documentation to be printed at    the very beginning.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Produces documentation in NaturalDocs format from the passed in class and proc metainformation.</p>
<p class='ruff'>The following options may be specified:</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_73' href="javascript:toggleSource('73')">Show source</a></p>
<div id='73' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::naturaldocs::generate_document {classprocinfodict args} {

    # Produces documentation in NaturalDocs format from the passed in
    # class and proc metainformation.
    #   classprocinfodict - dictionary containing meta information about the
    #    classes and procs
    #
    # The following options may be specified:
    #   -preamble DICT - a dictionary indexed by a namespace. Each value is
    #    a flat list of pairs consisting of a heading and
    #    corresponding content. These are inserted into the document
    #    before the actual class and command descriptions for a namespace.
    #    The key &quot;::&quot; corresponds to documentation to be printed at
    #    the very beginning.
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #   -modulename NAME - the name of the module. Used as the title for the document.
    #    If undefined, the string &quot;Reference&quot; is used.

    array set opts  [list  -includesource false  -hidenamespace &quot;&quot;  -modulename &quot;Reference&quot;  -preamble [dict create]  ]

    array set opts $args
    set doc [_fmtheading Title $opts(-modulename)]

    # Build a regexp that can be used to convert references to classes, methods
    # and procedures to links.
    set methods {}
    foreach {class_name class_info} [dict get $classprocinfodict classes] {
        foreach method_info [dict get $class_info methods] {
            lappend methods ${class_name}.[dict get $method_info name]
        }
        foreach method_info [dict get $class_info forwards] {
            lappend methods ${class_name}.[dict get $method_info name]
        }
    }
    set ref_regexp [_build_symbol_regexp  [concat  [dict keys [dict get $classprocinfodict procs]]  [dict keys [dict get $classprocinfodict classes]]  $methods
                            ]
                   ]

    if {[dict exists $opts(-preamble) &quot;::&quot;]} {
        # Print the toplevel (global stuff)
        foreach {sec paras} [dict get $opts(-preamble) &quot;::&quot;] {
            append doc [_fmtheading $sec]
            append doc [_fmtparas $paras $ref_regexp]
        }
    }

    set info_by_ns [_sift_classprocinfo $classprocinfodict]

    foreach ns [lsort -dictionary [dict keys $info_by_ns]] {
        # append doc [_fmtheading Section $ns] &lt;- this causes dup headings?
        if {[dict exists $opts(-preamble) $ns]} {
            foreach {sec paras} [dict get $opts(-preamble) $ns] {
                append doc [_fmtheading $sec]
                append doc [_fmtparas $paras $ref_regexp]
            }
        }

        # Output commands BEFORE classes else they show up as
        # part of a class definition unless they are grouped into a
        # separate section in which case summaries are duplicated.
        if {[dict exists $info_by_ns $ns procs]} {
            append doc [_fmtheading Section Commands]
            append doc [generate_procs [dict get $info_by_ns $ns procs]  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $ref_regexp  ]
        }

        if {[dict exists $info_by_ns $ns classes]} {
            append doc [generate_ooclasses [dict get $info_by_ns $ns classes]  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $ref_regexp  ]
        }
    }

    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::naturaldocs::generate_ooclass'>generate_ooclass</a><span class='ns_scope'> [<a href='#::ruff::formatter::naturaldocs'>::ruff::formatter::naturaldocs</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::naturaldocs'>naturaldocs</a>, <a href='#_top'>Top</a></p><p class='ruff'>Formats the documentation for a class in NaturalDocs format</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_ooclass</span> <span class='ruff_arg'>classinfo</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classinfo</span></td><td class='ruff_defitem'> class information in the format returned   by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-linkregexp REGEXP</span></td><td class='ruff_defitem'> if specified, any word matching the    regular expression REGEXP is marked as a link.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the class documentation as a NaturalDocs formatted string.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Formats the documentation for a class in NaturalDocs format</p>
<p class='ruff'>The following options may be specified:</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_74' href="javascript:toggleSource('74')">Show source</a></p>
<div id='74' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::naturaldocs::generate_ooclass {classinfo args} {


    # Formats the documentation for a class in NaturalDocs format
    # classinfo - class information in the format returned
    #   by extract_ooclass
    #
    # The following options may be specified:
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #   -linkregexp REGEXP - if specified, any word matching the
    #    regular expression REGEXP is marked as a link.
    #
    # Returns the class documentation as a NaturalDocs formatted string.

    variable markers
    variable leaders

    array set opts {
        -includesource false
        -hidenamespace &quot;&quot;
        -mergeconstructor false
        -linkregexp &quot;&quot;
    }
    array set opts $args

    array set aclass $classinfo
    set class_name [_trim_namespace $aclass(name) $opts(-hidenamespace)]

    set doc &quot;&quot;
    append doc [_fmtheading class $class_name]

    # Include constructor in main class definition
    if {$opts(-mergeconstructor) &amp;&amp; [info exists aclass(constructor)]} {
        error &quot;-mergeconstructor not implemented&quot;
        append doc [generate_proc_or_method $aclass(constructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -skipsections [list header name]  -linkregexp $opts(-linkregexp)  ]
    }

    # TBD - in the various sections below we include some leading text
    # that is not really necessary. This is because NaturalDocs assumes
    # anything starting with a &quot;:&quot; is a code line and does not format
    # or link any words in it. This is a problem since class names etc.
    # may start with a &quot;:&quot; if namespace qualified

    if {[llength $aclass(superclasses)]} {
        append doc [_fmtheading Superclasses]
        # Don't sort - order matters!
        append doc [_fmtpara &quot;The class inherits from the following classes: [join [_trim_namespace_multi $aclass(superclasses) $opts(-hidenamespace)] {, }]&quot; $opts(-linkregexp)]
    }
    if {[llength $aclass(mixins)]} {
        append doc [_fmtheading &quot;Mixins&quot;]

        # Don't sort - order matters!
        append doc [_fmtpara &quot;The class has the following classes mixed-in: [join [_trim_namespace_multi $aclass(mixins) $opts(-hidenamespace)] {, }]&quot; $opts(-linkregexp)]
    }

    if {[llength $aclass(subclasses)]} {
        # Don't sort - order matters!
        append doc [_fmtheading &quot;Subclasses&quot;]
        append doc [_fmtpara &quot;The following classes inherit from this class: [join [_trim_namespace_multi $aclass(subclasses) $opts(-hidenamespace)] {, }]&quot; $opts(-linkregexp)]
    }

    # Inherited and derived methods are listed as such.
    if {[llength $aclass(external_methods)]} {
        set external_methods {}
        foreach external_method $aclass(external_methods) {
            # Qualify the name with the name of the implenting class
            foreach {name imp_class} $external_method break
            if {$imp_class ne &quot;&quot;} {
                set name [_trim_namespace_multi $imp_class $opts(-hidenamespace)].$name
            }
            lappend external_methods $name
        }
        append doc [_fmtheading &quot;External methods&quot;]
        append doc [_fmtpara &quot;The following methods are either mixed-in or inherited: [join [lsort $external_methods] {, }]&quot; $opts(-linkregexp)]
    }
    if {[llength $aclass(filters)]} {
        append doc [_fmtheading &quot;Filters&quot;]
        append doc [_fmtpara &quot;The following methods are attached as filters for this class : [join [lsort $aclass(filters)] {, }]&quot; $opts(-linkregexp)]
    }

    # In NaturalDocs, the Class heading establishes the &quot;scope&quot;
    # and we can straightaway list the methods directly after it and
    # have them tagged as belonging to the class.

    if {[info exists aclass(constructor)] &amp;&amp; !$opts(-mergeconstructor)} {
        append doc [generate_proc_or_method $aclass(constructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $opts(-linkregexp)  ]
    }
    if {[info exists aclass(destructor)]} {
        append doc [generate_proc_or_method $aclass(destructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $opts(-linkregexp)  ]
    }

    # We want methods and forwarded methods listed together and sorted
    array set methods {}
    foreach methodinfo $aclass(methods) {
        set methods([dict get $methodinfo name]) [list method $methodinfo]
    }
    if {[info exists aclass(forwards)]} {
        foreach forwardinfo $aclass(forwards) {
            set methods([dict get $forwardinfo name]) [list forward $forwardinfo]
        }
    }

    foreach name [lsort [array names methods]] {
        foreach {type info} $methods($name) break
        if {$type eq &quot;method&quot;} {
            append doc [generate_proc_or_method $info  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -linkregexp $opts(-linkregexp)  ]
        } else {
            # TBD - check formatting of forwarded methods
            append doc [_fmtheading &quot;Method&quot; $name]
            # TBD - link to forwarded method if possible
            append doc [_fmtpara &quot;Method forwarded to [dict get $info forward]&quot; $opts(-linkregexp)]
        }
    }

    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::naturaldocs::generate_ooclasses'>generate_ooclasses</a><span class='ns_scope'> [<a href='#::ruff::formatter::naturaldocs'>::ruff::formatter::naturaldocs</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::naturaldocs'>naturaldocs</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a list of class information elements returns as string containing class documentation formatted for NaturalDocs</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_ooclasses</span> <span class='ruff_arg'>classinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classinfodict</span></td><td class='ruff_defitem'> dictionary keyed by class name and each element   of which is in the format returned by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a list of class information elements returns as string containing class documentation formatted for NaturalDocs</p>
<p class='ruff'>Additional parameters are passed on to the <a href='#::ruff::formatter::naturaldocs::generate_ooclass'>generate_ooclass</a> procedure.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_75' href="javascript:toggleSource('75')">Show source</a></p>
<div id='75' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::naturaldocs::generate_ooclasses {classinfodict args} {

    # Given a list of class information elements returns as string
    # containing class documentation formatted for NaturalDocs
    # classinfodict - dictionary keyed by class name and each element
    #   of which is in the format returned by extract_ooclass
    #
    # Additional parameters are passed on to the generate_ooclass procedure.

    set doc &quot;&quot;
    foreach name [lsort [dict keys $classinfodict]] {
        append doc  [eval [list generate_ooclass [dict get $classinfodict $name]] $args]
        append doc &quot;\n\n&quot;
    }
    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::naturaldocs::generate_proc_or_method'>generate_proc_or_method</a><span class='ns_scope'> [<a href='#::ruff::formatter::naturaldocs'>::ruff::formatter::naturaldocs</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::naturaldocs'>naturaldocs</a>, <a href='#_top'>Top</a></p><p class='ruff'>Formats the documentation for a proc in NaturalDocs format</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_proc_or_method</span> <span class='ruff_arg'>procinfo</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procinfo</span></td><td class='ruff_defitem'> proc or method information in the format returned   by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-linkregexp REGEXP</span></td><td class='ruff_defitem'> if specified, any word matching the    regular expression REGEXP is marked as a link.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-skipsections SECTIONLIST</span></td><td class='ruff_defitem'> a list of sections to be left    out from the generated <a href='#::ruff::document'>document</a>. This is generally useful    if the return value is to be included as part of a larger    section (e.g. constructor within a class)</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the proc documentation as a NaturalDocs formatted string.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Formats the documentation for a proc in NaturalDocs format</p>
<p class='ruff'>The following options may be specified:</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_76' href="javascript:toggleSource('76')">Show source</a></p>
<div id='76' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::naturaldocs::generate_proc_or_method {procinfo args} {

    # Formats the documentation for a proc in NaturalDocs format
    # procinfo - proc or method information in the format returned
    #   by extract_ooclass
    #
    # The following options may be specified:
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #   -skipsections SECTIONLIST - a list of sections to be left
    #    out from the generated document. This is generally useful
    #    if the return value is to be included as part of a larger
    #    section (e.g. constructor within a class)
    #   -linkregexp REGEXP - if specified, any word matching the
    #    regular expression REGEXP is marked as a link.
    #
    # Returns the proc documentation as a NaturalDocs formatted string.

    variable markers
    variable leaders

    array set opts {-includesource false
        -hidenamespace &quot;&quot;
        -skipsections {}
        -linkregexp &quot;&quot;
    }
    array set opts $args

    array set aproc $procinfo

    set doc &quot;&quot;;                 # Document string

    # In NaturalDocs, method names are never qualifed by a class prefix
    # since they
    # automatically get scoped by previous Class or namespace headings.
    set header_title [_trim_namespace $aproc(name) $opts(-hidenamespace)]
    set proc_name [_trim_namespace $aproc(name) $opts(-hidenamespace)]

    if {[lsearch -exact $opts(-skipsections) header] &lt; 0} {
        if {$aproc(proctype) eq &quot;method&quot;} {
            append doc [_fmtheading method $header_title]
        } else {
            append doc [_fmtheading proc $header_title]
        }
    }

    # Loop through all the paragraphs
    append doc [_fmtparas $aproc(description) $opts(-linkregexp)]

    if {[info exists aproc(return)] &amp;&amp; $aproc(return) ne &quot;&quot;} {
        append doc [_fmtheading return]
        append doc [_fmtpara $aproc(return) $opts(-linkregexp)]
    }

    # Now spit out the parameter list. Note we do this AFTER
    # the paragraphs so NaturalDocs correctly picks up
    # a summary line (it wants it right after the topic.
    # Construct the synopsis and simultaneously the parameter descriptions
    set desclist {};            # For the parameter descriptions
    set arglist {};             # Used later for synopsis
    foreach param $aproc(parameters) {
        set name [dict get $param name]
        set desc {}
        if {[dict get $param type] eq &quot;parameter&quot;} {
            lappend arglist $name
            if {[dict exists $param default]} {
                # No visual way in NaturalDocs to show as optional so
                # explicitly state (although the synopsis will show the
                # default)
                lappend desc &quot;(optional, default [dict get $param default])&quot;
            }
        }
        if {[dict exists $param description]} {
            lappend desc &quot;[dict get $param description]&quot;
        }

        lappend desclist $name [join $desc &quot; &quot;]
    }

    if {[llength $desclist]} {
        append doc [_fmtheading parameters]
        # Parameters are output as a list.
        append doc [_fmtdeflist $desclist $opts(-linkregexp)]
    }

    # Do we include the source code in the documentation?
    if {$opts(-includesource)} {
        append doc [_fmtheading source]
        append doc &quot;$leaders(text)(start code)&quot;
        append doc [::textutil::adjust::indent $aproc(source) $leaders(text)]\n
        append doc &quot;$leaders(text)(end code)&quot;
    }

    # Synopsis - write a dummy proc WITHOUT any comment headers and
    # NaturalDocs will pick out the appropriate elements
    if {$aproc(proctype) ne &quot;method&quot;} {
        append doc &quot;\nproc $proc_name \{$arglist\} {}\n&quot;
    } else {
        switch -exact -- $aproc(name) {
            constructor {append doc &quot;\nconstructor $arglist {}\n&quot;}
            destructor  {append doc &quot;\ndestructor {} {}\n&quot;}
            default  {append doc &quot;\nmethod $aproc(name) \{$arglist\} {}\n&quot;}
        }
    }

    return &quot;${doc}\n&quot;
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::naturaldocs::generate_procs'>generate_procs</a><span class='ns_scope'> [<a href='#::ruff::formatter::naturaldocs'>::ruff::formatter::naturaldocs</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::naturaldocs'>naturaldocs</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a dictionary of proc information elements returns a string containing documentation formatted for NaturalDocs</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_procs</span> <span class='ruff_arg'>procinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procinfodict</span></td><td class='ruff_defitem'> dictionary keyed by name of the proc with the associated   value being in the format returned by <a href='#::ruff::extract_proc'>extract_proc</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns documentation string in NaturalDocs format with procedure descriptions sorted in alphabetical order.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a dictionary of proc information elements returns a string containing documentation formatted for NaturalDocs</p>
<p class='ruff'>Additional parameters are passed on to the generate_proc procedure.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_77' href="javascript:toggleSource('77')">Show source</a></p>
<div id='77' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::naturaldocs::generate_procs {procinfodict args} {

    # Given a dictionary of proc information elements returns a string
    # containing documentation formatted for NaturalDocs
    # procinfodict - dictionary keyed by name of the proc with the associated
    #   value being in the format returned by extract_proc
    #
    # Additional parameters are passed on to the generate_proc procedure.
    #
    # Returns documentation string in NaturalDocs format with
    # procedure descriptions sorted in alphabetical order.

    set doc &quot;&quot;
    foreach name [lsort -dictionary [dict keys $procinfodict]] {
        append doc  [eval [list generate_proc_or_method [dict get $procinfodict $name]] $args]\n\n
    }

    return $doc
}
</pre></div>
</div>


<h1 class='ruff'><a name='::ruff::formatter::robodoc'>::ruff::formatter::robodoc</a></h1>
<h2 class='ruff'><a name='::ruff::formatter::robodoc-Commands'>Commands</a></h2>
<h4 class='ruff'><a name='::ruff::formatter::robodoc::generate_document'>generate_document</a><span class='ns_scope'> [<a href='#::ruff::formatter::robodoc'>::ruff::formatter::robodoc</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::robodoc'>robodoc</a>, <a href='#_top'>Top</a></p><p class='ruff'>Produces documentation in robodoc format from the passed in class and proc metainformation.</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_document</span> <span class='ruff_arg'>classprocinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classprocinfodict</span></td><td class='ruff_defitem'> dictionary containing meta information about the    classes and procs</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-preamble DICT</span></td><td class='ruff_defitem'> a dictionary indexed by a namespace. Each value is    a flat list of pairs consisting of a heading and    corresponding content. These are inserted into the <a href='#::ruff::document'>document</a>    before the actual class and command descriptions for a namespace.    The key &quot;::&quot; corresponds to documentation to be printed at    the very beginning.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Produces documentation in robodoc format from the passed in class and proc metainformation.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_78' href="javascript:toggleSource('78')">Show source</a></p>
<div id='78' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::robodoc::generate_document {classprocinfodict args} {

    # Produces documentation in robodoc format from the passed in
    # class and proc metainformation.
    #  classprocinfodict - dictionary containing meta information about the
    #    classes and procs
    #   -preamble DICT - a dictionary indexed by a namespace. Each value is
    #    a flat list of pairs consisting of a heading and
    #    corresponding content. These are inserted into the document
    #    before the actual class and command descriptions for a namespace.
    #    The key &quot;::&quot; corresponds to documentation to be printed at
    #    the very beginning.
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.

    variable markers

    array set opts  [list  -includesource false  -hidenamespace &quot;&quot;  -modulename MODULE  -preamble [dict create]  ]

    array set opts $args
    set doc &quot;&quot;

    if {[dict exists $opts(-preamble) &quot;::&quot;]} {
        # Print the toplevel (global stuff)
        foreach {sec paras} [dict get $opts(-preamble) &quot;::&quot;] {
            append doc &quot;$markers(module) $opts(-modulename)/$sec\n&quot;
            append doc [_fmtitem DESCRIPTION]
            append doc [_fmtparas $paras]
            append doc &quot;$markers(end)\n&quot;
        }
    }

    set info_by_ns [_sift_classprocinfo $classprocinfodict]
    foreach ns [lsort -dictionary [dict keys $info_by_ns]] {
        # TBD - does the following line cause dup headings?
        # append doc [_fmtheading Section $ns]
        if {[dict exists $opts(-preamble) $ns]} {
            foreach {sec paras} [dict get $opts(-preamble) $ns] {
                append doc &quot;$markers(module) $ns/$sec\n&quot;
                append doc [_fmtitem DESCRIPTION]
                append doc [_fmtparas $paras]
                append doc &quot;$markers(end)\n&quot;
            }
        }

        if {[dict exists $info_by_ns $ns classes]} {
            append doc [generate_ooclasses [dict get $info_by_ns $ns classes]  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  ]
        }
        if {[dict exists $info_by_ns $ns procs]} {
            append doc [generate_procs [dict get $info_by_ns $ns procs]  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  ]
        }
    }

    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::robodoc::generate_ooclass'>generate_ooclass</a><span class='ns_scope'> [<a href='#::ruff::formatter::robodoc'>::ruff::formatter::robodoc</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::robodoc'>robodoc</a>, <a href='#_top'>Top</a></p><p class='ruff'>Formats the documentation for a class in robodoc format</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_ooclass</span> <span class='ruff_arg'>classinfo</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classinfo</span></td><td class='ruff_defitem'> class information in the format returned   by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the class documentation as a robodoc formatted string.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Formats the documentation for a class in robodoc format</p>
<p class='ruff'>The following options may be specified:</p>
<p class='ruff'>Because robodoc does not have a heading for mix-ins, they are include within the DERIVED FROM section.</p>
<p class='ruff'>Documentation for a class only lists the method names. The methods themselves are documented separately.</p>
<p class='ruff'>Inherited and derived methods are listed as such.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_79' href="javascript:toggleSource('79')">Show source</a></p>
<div id='79' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::robodoc::generate_ooclass {classinfo args} {


    # Formats the documentation for a class in robodoc format
    # classinfo - class information in the format returned
    #   by extract_ooclass
    #
    # The following options may be specified:
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #
    # Returns the class documentation as a robodoc formatted string.

    variable markers
    variable leaders

    array set opts {-includesource false -hidenamespace &quot;&quot; -mergeconstructor true}
    array set opts $args

    array set aclass $classinfo
    set class_name [_trim_namespace $aclass(name) $opts(-hidenamespace)]

    set doc &quot;&quot;
    set header_title &quot;[namespace qualifiers $aclass(name)]/[namespace tail $aclass(name)]&quot;
    append doc &quot;$markers(class) $header_title\n&quot;

    append doc [_fmtitem NAME $class_name]

    # Include constructor in main class definition
    if {$opts(-mergeconstructor) &amp;&amp; [info exists aclass(constructor)]} {
        append doc [generate_proc_or_method $aclass(constructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)  -skipsections [list header name]  ]
    }

    #ruff
    # Because robodoc does not have a heading for mix-ins, they are include
    # within the DERIVED FROM section.
    if {[llength $aclass(superclasses)] || [llength $aclass(mixins)]} {
        append doc [_fmtitem &quot;DERIVED FROM&quot;]

        # Don't sort - order matters! Also, there is no heading for mixins
        # so we add them here.
        if {[llength $aclass(mixins)]} {
            # Don't sort - order matters!
            append doc [_fmtpara &quot;Mixins: [join [_trim_namespace_multi $aclass(mixins) $opts(-hidenamespace)] {, }]&quot;]
        }
        if {[llength $aclass(superclasses)]} {
            append doc [_fmtpara &quot;Superclasses: [join [_trim_namespace_multi $aclass(superclasses) $opts(-hidenamespace)] {, }]&quot;]
        }
    }


    if {[llength $aclass(subclasses)]} {
        # Don't sort - order matters!
        append doc [_fmtitem &quot;DERIVED BY&quot; [join [_trim_namespace_multi $aclass(subclasses) $opts(-hidenamespace)] &quot;, &quot;]]
    }

    #ruff
    # Documentation for a class only lists the method names. The
    # methods themselves are documented separately.
    set class_methods {}
    foreach methodinfo $aclass(methods) {
        lappend class_methods ${class_name}.[dict get $methodinfo name]
    }
    if {[info exists aclass(constructor)] &amp;&amp; !$opts(-mergeconstructor)} {
        set class_methods [linsert $class_methods 0 constructor]
    }
    if {[info exists aclass(destructor)]} {
        set class_methods [linsert $class_methods 0 destructor]
    }
    append doc [_fmtitem METHODS]
    append doc [_fmtpara [join $class_methods &quot;, &quot;]]

    #ruff
    # Inherited and derived methods are listed as such.
    if {[llength $aclass(external_methods)]} {
        set external_methods {}
        foreach external_method $aclass(external_methods) {
            # Qualify the name with the name of the implenting class
            foreach {name imp_class} $external_method break
            if {$imp_class ne &quot;&quot;} {
                set name [_trim_namespace_multi $imp_class $opts(-hidenamespace)].$name
            }
            lappend external_methods $name
        }
        append doc [_fmtpara &quot;External methods: [join [lsort $external_methods] {, }]&quot;]
    }
    if {[llength $aclass(filters)]} {
        append doc [_fmtpara &quot;Filters: [join [lsort $aclass(filters)] {, }]&quot;]
    }

    # Finish up the class description
    append doc $markers(end)

    # Next we will generate the documentation for the methods themselves

    append doc &quot;\n\n&quot;

    if {[info exists aclass(constructor)] &amp;&amp; !$opts(-mergeconstructor)} {
        append doc [generate_proc_or_method $aclass(constructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)]
    }
    if {[info exists aclass(destructor)]} {
        append doc [generate_proc_or_method $aclass(destructor)  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)]
    }

    # We want methods and forwarded methods listed together and sorted
    array set methods {}
    foreach methodinfo $aclass(methods) {
        set methods([dict get $methodinfo name]) [list method $methodinfo]
    }
    if {[info exists aclass(forwards)]} {
        foreach forwardinfo $aclass(forwards) {
            set methods([dict get $forwardinfo name]) [list forward $forwardinfo]
        }
    }

    foreach name [lsort [array names methods]] {
        foreach {type info} $methods($name) break
        if {$type eq &quot;method&quot;} {
            append doc [generate_proc_or_method $info  -includesource $opts(-includesource)  -hidenamespace $opts(-hidenamespace)]
        } else {
            # Forwarded method
            set header_title &quot;[namespace qualifiers $aclass(name)]/[namespace tail $aclass(name)].$name&quot;
            append doc &quot;\n$markers(method) $header_title\n&quot;
            append doc [_fmtitem NAME &quot;[_trim_namespace $aclass(name) $opts(-hidenamespace)].$name&quot;]
            # TBD - link to forwarded method if possible
            append doc [_fmtpara &quot;Method forwarded to [dict get $info forward].&quot;]
            append doc &quot;\n$markers(end)\n&quot;
        }
    }

    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::robodoc::generate_ooclasses'>generate_ooclasses</a><span class='ns_scope'> [<a href='#::ruff::formatter::robodoc'>::ruff::formatter::robodoc</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::robodoc'>robodoc</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a list of class information elements returns as string containing class documentation formatted for robodoc</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_ooclasses</span> <span class='ruff_arg'>classinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>classinfodict</span></td><td class='ruff_defitem'> dictionary keyed by class name and each element   of which is in the format returned by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a list of class information elements returns as string containing class documentation formatted for robodoc</p>
<p class='ruff'>Additional parameters are passed on to the <a href='#::ruff::formatter::robodoc::generate_ooclass'>generate_ooclass</a> procedure.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_80' href="javascript:toggleSource('80')">Show source</a></p>
<div id='80' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::robodoc::generate_ooclasses {classinfodict args} {

    # Given a list of class information elements returns as string
    # containing class documentation formatted for robodoc
    # classinfodict - dictionary keyed by class name and each element
    #   of which is in the format returned by extract_ooclass
    #
    # Additional parameters are passed on to the generate_ooclass procedure.

    set doc &quot;&quot;
    foreach name [lsort [dict keys $classinfodict]] {
        append doc  [eval [list generate_ooclass [dict get $classinfodict $name]] $args]
        append doc &quot;\n\n&quot;
    }
    return $doc
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::robodoc::generate_proc_or_method'>generate_proc_or_method</a><span class='ns_scope'> [<a href='#::ruff::formatter::robodoc'>::ruff::formatter::robodoc</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::robodoc'>robodoc</a>, <a href='#_top'>Top</a></p><p class='ruff'>Formats the documentation for a proc in robodoc format</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_proc_or_method</span> <span class='ruff_arg'>procinfo</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procinfo</span></td><td class='ruff_defitem'> proc or method information in the format returned   by <a href='#::ruff::extract_ooclass'>extract_ooclass</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-hidenamespace NAMESPACE</span></td><td class='ruff_defitem'> if specified as non-empty,    program element names beginning with NAMESPACE are shown    with that namespace component removed.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-includesource BOOLEAN</span></td><td class='ruff_defitem'> if true, the source code of the     procedure is also included. Default value is false.</td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>-skipsections SECTIONLIST</span></td><td class='ruff_defitem'> a list of sections to be left    out from the generated <a href='#::ruff::document'>document</a>. This is generally useful    if the return value is to be included as part of a larger    section (e.g. constructor within a class)</td></tr>
</table>
<h6 class='ruff'>Return value</h6>
<p class='ruff'>Returns the proc documentation as a robodoc formatted string.</p>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Formats the documentation for a proc in robodoc format</p>
<p class='ruff'>The following options may be specified:</p>
<p class='ruff'>In order for the Robodoc cross-links to work, the header markers generated use the namespace as the section followed by the command name or class name and method combined with a period.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_81' href="javascript:toggleSource('81')">Show source</a></p>
<div id='81' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::robodoc::generate_proc_or_method {procinfo args} {

    # Formats the documentation for a proc in robodoc format
    # procinfo - proc or method information in the format returned
    #   by extract_ooclass
    #
    # The following options may be specified:
    #   -includesource BOOLEAN - if true, the source code of the
    #     procedure is also included. Default value is false.
    #   -hidenamespace NAMESPACE - if specified as non-empty,
    #    program element names beginning with NAMESPACE are shown
    #    with that namespace component removed.
    #   -skipsections SECTIONLIST - a list of sections to be left
    #    out from the generated document. This is generally useful
    #    if the return value is to be included as part of a larger
    #    section (e.g. constructor within a class)
    # Returns the proc documentation as a robodoc formatted string.

    variable markers
    variable leaders

    array set opts {-includesource false -hidenamespace &quot;&quot; -skipsections {}}
    array set opts $args

    array set aproc $procinfo

    set doc &quot;&quot;;                 # Document string

    #ruff
    # In order for the Robodoc cross-links to work, the header markers
    # generated use the namespace as the section followed by the command
    # name or class name and method combined with a period.
    if {$aproc(proctype) eq &quot;method&quot;} {
        set header_title &quot;[namespace qualifiers $aproc(class)]/[namespace tail $aproc(class)].$aproc(name)&quot;
        set proc_name [_trim_namespace $aproc(class) $opts(-hidenamespace)].$aproc(name)
    } else {
        set header_title [namespace qualifiers $aproc(name)]/[namespace tail $aproc(name)]
        set proc_name [_trim_namespace $aproc(name) $opts(-hidenamespace)]
    }

    # TBD - mark header as internal depending on whether private method
    if {[lsearch -exact -nocase $opts(-skipsections) header] &lt; 0} {
        if {$aproc(proctype) eq &quot;method&quot;} {
            append doc &quot;$markers(method) $header_title\n&quot;
        } else {
            append doc &quot;$markers(function) $header_title\n&quot;
        }
    }

    if {[lsearch -exact -nocase $opts(-skipsections) name] &lt; 0} {
        append doc [_fmtitem NAME $proc_name]
    }


    # Construct the synopsis and simultaneously the parameter descriptions
    set desclist {};            # For the parameter descriptions
    set arglist {};             # For the synopsis
    # Construct command synopsis and parameter block
    # Unfortunately Robodoc does not seem to have any special way of
    # formatting these. Just output as text strings
    foreach param $aproc(parameters) {
        set name [dict get $param name]
        if {[dict get $param type] eq &quot;parameter&quot;} {
            lappend arglist $name
        }
        set desc &quot;$name --&quot;
        if {[dict exists $param default]} {
            # No visual way in robodoc to show as optional so explicitly state
            append desc &quot; (optional, default [dict get $param default])&quot;
        }
        if {[dict exists $param description]} {
            append desc &quot; [dict get $param description]&quot;
        }

        lappend desclist $desc
    }

    # Synopsis
    if {$aproc(proctype) ne &quot;method&quot;} {
        append doc [_fmtitem SYNOPSIS &quot;$proc_name $arglist&quot;]
    } else {
        switch -exact -- $aproc(name) {
            constructor {append doc [_fmtitem SYNOPSIS &quot;::oo::class create [_trim_namespace $aproc(class) $opts(-hidenamespace)] $arglist&quot;]}
            destructor  {append doc [_fmtitem SYNOPSIS &quot;OBJECT destroy&quot;]}
            default  {append doc [_fmtitem SYNOPSIS &quot;OBJECT $aproc(name) $arglist&quot;]}
        }
    }

    # Parameter descriptions
    if {[llength $desclist]} {
        append doc [_fmtitem PARAMETERS]
        # Parameters are output as a list.
        append doc [_fmtlist $desclist]
    }

    append doc [_fmtitem DESCRIPTION]


    # Loop through all the paragraphs
    # We need to remember the last character to detect possible errors
    # in Robodoc's list recognition. Either the list must follow a item
    # header or a line ending in colon (:). We pass : as the second
    # parameter below because we just put out a item header which
    # is equivalent.
    append doc [_fmtparas $aproc(description) :]

    if {[info exists aproc(return)] &amp;&amp; $aproc(return) ne &quot;&quot;} {
        append doc [_fmtpara $aproc(return)]
    }

    if {$opts(-includesource)} {
        append doc [_fmtitem SOURCE]
        append doc [::textutil::adjust::indent $aproc(source) $leaders(text)]\n
    }

    if {[lsearch -exact -nocase $opts(-skipsections) header] &lt; 0} {
        append doc $markers(end)
    }

    return &quot;${doc}\n&quot;
}
</pre></div>
</div>


<h4 class='ruff'><a name='::ruff::formatter::robodoc::generate_procs'>generate_procs</a><span class='ns_scope'> [<a href='#::ruff::formatter::robodoc'>::ruff::formatter::robodoc</a>]</span></h4>

<p class='linkline'><a href='#::ruff::formatter::robodoc'>robodoc</a>, <a href='#_top'>Top</a></p><p class='ruff'>Given a dictionary of proc information elements returns a string containing documentation formatted for robodoc</p>
<p><div class='ruff_synopsis'><span class='ruff_cmd'>generate_procs</span> <span class='ruff_arg'>procinfodict</span> <span class='ruff_arg'>args</span></div></p>
<h6 class='ruff'>Parameters</h6>
<table class='ruff_deflist'>
<tr><td class='ruff_defitem'><span class='ruff_arg'>procinfodict</span></td><td class='ruff_defitem'> dictionary keyed by name of the proc with the associated   value being in the format returned by <a href='#::ruff::extract_proc'>extract_proc</a></td></tr>
<tr><td class='ruff_defitem'><span class='ruff_arg'>args</span></td><td class='ruff_defitem'>Additional options.</td></tr>
</table>
<h6 class='ruff'>Description</h6>
<p class='ruff'>Given a dictionary of proc information elements returns a string containing documentation formatted for robodoc</p>
<p class='ruff'>Additional parameters are passed on to the generate_proc procedure.</p>
<div class='ruff_source'><p class='ruff_source_link'><a id='l_82' href="javascript:toggleSource('82')">Show source</a></p>
<div id='82' class='ruff_dyn_src'><pre>
proc ::ruff::formatter::robodoc::generate_procs {procinfodict args} {

    # Given a dictionary of proc information elements returns a string
    # containing documentation formatted for robodoc
    # procinfodict - dictionary keyed by name of the proc with the associated
    #   value being in the format returned by extract_proc
    #
    # Additional parameters are passed on to the generate_proc procedure.

    set doc &quot;&quot;

    foreach name [lsort -dictionary [dict keys $procinfodict]] {
        append doc  [eval [list generate_proc_or_method [dict get $procinfodict $name]] $args]\n\n
    }

    return $doc
}
</pre></div>
</div>


</div></div><div class='yui-b navbox'><h1><a href='#::ruff'>::ruff</a></h1><h2><a href='#Introduction'>Introduction</a></h2><h2><a href='#Usage'>Usage</a></h2><h2><a href='#Input format'>Input format</a></h2><h2><a href='#Output formats'>Output formats</a></h2><h2><a href='#::ruff-Commands'>Commands</a></h2><h4><a class='tooltip' href='#::ruff::distill_body'>distill_body<span>Given a procedure or method body, returns the documentation lines as a list.</span></a></h4><h4><a class='tooltip' href='#::ruff::distill_docstring'>distill_docstring<span>Splits a documentation string to return the documentation lines as a list.</span></a></h4><h4><a class='tooltip' href='#::ruff::document'>document<span>Generates documentation for the specified namespaces using the specified formatter.</span></a></h4><h4><a class='tooltip' href='#::ruff::document_namespace'>document_namespace<span>Obsolete, use document_namespaces instead.</span></a></h4><h4><a class='tooltip' href='#::ruff::document_namespaces'>document_namespaces<span>Generates documentation for the specified namespaces using the specified formatter.</span></a></h4><h4><a class='tooltip' href='#::ruff::document_self'>document_self<span>Generates documentation for Ruff!</span></a></h4><h4><a class='tooltip' href='#::ruff::extract'>extract<span>Extracts metainformation for procs and classes</span></a></h4><h4><a class='tooltip' href='#::ruff::extract_docstring'>extract_docstring<span>Parses a documentation string to return a structured text representation.</span></a></h4><h4><a class='tooltip' href='#::ruff::extract_namespace'>extract_namespace<span>Extracts metainformation for procs and objects in a namespace</span></a></h4><h4><a class='tooltip' href='#::ruff::extract_namespaces'>extract_namespaces<span>Extracts metainformation for procs and objects in one or more namespace</span></a></h4><h4><a class='tooltip' href='#::ruff::extract_ooclass'>extract_ooclass<span>Extracts metainformation about the specified class</span></a></h4><h4><a class='tooltip' href='#::ruff::extract_ooclass_method'>extract_ooclass_method<span>Extracts metainformation for the method in oo:: class</span></a></h4><h4><a class='tooltip' href='#::ruff::extract_proc'>extract_proc<span>Extracts meta information from a Tcl procedure.</span></a></h4><h4><a class='tooltip' href='#::ruff::extract_proc_or_method'>extract_proc_or_method<span>Helper procedure used by extract_proc and extract_ooclass_method to construct metainformation for a method or proc.</span></a></h4><h4><a class='tooltip' href='#::ruff::formatters'>formatters<span>Get the list of supported formatters.</span></a></h4><h4><a class='tooltip' href='#::ruff::get_ooclass_method_path'>get_ooclass_method_path<span>Calculates the class search order for a method of the specified class</span></a></h4><h4><a class='tooltip' href='#::ruff::locate_ooclass_method'>locate_ooclass_method<span>Locates the classe that implement the specified method of a class</span></a></h4><h4><a class='tooltip' href='#::ruff::parse'>parse<span>Creates a parse structure given a list of lines that are assumed to be documentation for a programming structure</span></a></h4><h1><a href='#::ruff::app'>::ruff::app</a></h1><h2><a href='#::ruff::app-Commands'>Commands</a></h2><h4><a class='tooltip' href='#::ruff::app::log_error'>log_error<span>Stub function to log Ruff! errors.</span></a></h4><h1><a href='#::ruff::formatter::doctools'>::ruff::formatter::doctools</a></h1><h2><a href='#::ruff::formatter::doctools-Commands'>Commands</a></h2><h4><a href='#::ruff::formatter::doctools::escape'>escape</a></h4><h4><a class='tooltip' href='#::ruff::formatter::doctools::generate_document'>generate_document<span>Produces documentation in doctools format from the passed in class and proc metainformation.</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::doctools::generate_ooclass'>generate_ooclass<span>Formats the documentation for a class in doctools format</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::doctools::generate_ooclasses'>generate_ooclasses<span>Given a list of class information elements returns as string containing class documentation formatted for doctools</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::doctools::generate_proc_or_method'>generate_proc_or_method<span>Formats the documentation for a proc in doctools format</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::doctools::generate_procs'>generate_procs<span>Given a dictionary of proc information elements returns a string containing documentation formatted for doctools</span></a></h4><h1><a href='#::ruff::formatter::html'>::ruff::formatter::html</a></h1><h2><a href='#::ruff::formatter::html-Commands'>Commands</a></h2><h4><a class='tooltip' href='#::ruff::formatter::html::escape'>escape<span>Returns the escaped string</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::html::generate_document'>generate_document<span>Produces documentation in HTML format from the passed in class and proc metainformation.</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::html::generate_ooclass'>generate_ooclass<span>Formats the documentation for a class in HTML format</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::html::generate_ooclasses'>generate_ooclasses<span>Given a list of class information elements returns as string containing class documentation formatted for NaturalDocs</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::html::generate_proc_or_method'>generate_proc_or_method<span>Formats the documentation for a proc in HTML format</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::html::generate_procs'>generate_procs<span>Given a dictionary of proc information elements returns a string containing HTML format documentation.</span></a></h4><h1><a href='#::ruff::formatter::naturaldocs'>::ruff::formatter::naturaldocs</a></h1><h2><a href='#::ruff::formatter::naturaldocs-Commands'>Commands</a></h2><h4><a class='tooltip' href='#::ruff::formatter::naturaldocs::generate_document'>generate_document<span>Produces documentation in NaturalDocs format from the passed in class and proc metainformation.</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::naturaldocs::generate_ooclass'>generate_ooclass<span>Formats the documentation for a class in NaturalDocs format</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::naturaldocs::generate_ooclasses'>generate_ooclasses<span>Given a list of class information elements returns as string containing class documentation formatted for NaturalDocs</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::naturaldocs::generate_proc_or_method'>generate_proc_or_method<span>Formats the documentation for a proc in NaturalDocs format</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::naturaldocs::generate_procs'>generate_procs<span>Given a dictionary of proc information elements returns a string containing documentation formatted for NaturalDocs</span></a></h4><h1><a href='#::ruff::formatter::robodoc'>::ruff::formatter::robodoc</a></h1><h2><a href='#::ruff::formatter::robodoc-Commands'>Commands</a></h2><h4><a class='tooltip' href='#::ruff::formatter::robodoc::generate_document'>generate_document<span>Produces documentation in robodoc format from the passed in class and proc metainformation.</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::robodoc::generate_ooclass'>generate_ooclass<span>Formats the documentation for a class in robodoc format</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::robodoc::generate_ooclasses'>generate_ooclasses<span>Given a list of class information elements returns as string containing class documentation formatted for robodoc</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::robodoc::generate_proc_or_method'>generate_proc_or_method<span>Formats the documentation for a proc in robodoc format</span></a></h4><h4><a class='tooltip' href='#::ruff::formatter::robodoc::generate_procs'>generate_procs<span>Given a dictionary of proc information elements returns a string containing documentation formatted for robodoc</span></a></h4></div></div><div id='ft'><div style='float: right;'>Document generated by Ruff!</div><div>&copy; 2009 Ashok P. Nadkarni</div></div>
</div></body></html>
